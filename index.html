<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>磐石</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="danielding">
  
  
  <meta name="description" content="danielding&apos;s blog | java | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="磐石">
<meta property="og:url" content="https://danieldingzju.github.io/index.html">
<meta property="og:site_name" content="磐石">
<meta property="og:description" content="danielding&apos;s blog | java | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="磐石">
<meta name="twitter:description" content="danielding&apos;s blog | java | bi">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e36f59d471ddc16c84ea8f9ea2e342ed";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">磐石</a></h1>
    <p><a href="/">工程狮</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="false">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/12/20/JVMS7笔记/">
  <time datetime="2015-12-20T08:07:58.000Z">
    12月 20 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/12/20/JVMS7笔记/">JVMS7笔记</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>&lt;!doctype html&gt;</p>
<html><br><head><br><meta charset="utf-8"><br><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"><br><style><br>h1,<br>h2,<br>h3,<br>h4,<br>h5,<br>h6,<br>p,<br>blockquote {<br>    margin: 0;<br>    padding: 0;<br>}<br>body {<br>    font-family: “Helvetica Neue”, Helvetica, “Hiragino Sans GB”, Arial, sans-serif;<br>    font-size: 13px;<br>    line-height: 18px;<br>    color: #737373;<br>    background-color: white;<br>    margin: 10px 13px 10px 13px;<br>}<br>table {<br>    margin: 10px 0 15px 0;<br>    border-collapse: collapse;<br>}<br>td,th {<br>    border: 1px solid #ddd;<br>    padding: 3px 10px;<br>}<br>th {<br>    padding: 5px 10px;<br>}<br><br>a {<br>    color: #0069d6;<br>}<br>a:hover {<br>    color: #0050a3;<br>    text-decoration: none;<br>}<br>a img {<br>    border: none;<br>}<br>p {<br>    margin-bottom: 9px;<br>}<br>h1,<br>h2,<br>h3,<br>h4,<br>h5,<br>h6 {<br>    color: #404040;<br>    line-height: 36px;<br>}<br>h1 {<br>    margin-bottom: 18px;<br>    font-size: 30px;<br>}<br>h2 {<br>    font-size: 24px;<br>}<br>h3 {<br>    font-size: 18px;<br>}<br>h4 {<br>    font-size: 16px;<br>}<br>h5 {<br>    font-size: 14px;<br>}<br>h6 {<br>    font-size: 13px;<br>}<br>hr {<br>    margin: 0 0 19px;<br>    border: 0;<br>    border-bottom: 1px solid #ccc;<br>}<br>blockquote {<br>    padding: 13px 13px 21px 15px;<br>    margin-bottom: 18px;<br>    font-family:georgia,serif;<br>    font-style: italic;<br>}<br>blockquote:before {<br>    content:”\201C”;<br>    font-size:40px;<br>    margin-left:-10px;<br>    font-family:georgia,serif;<br>    color:#eee;<br>}<br>blockquote p {<br>    font-size: 14px;<br>    font-weight: 300;<br>    line-height: 18px;<br>    margin-bottom: 0;<br>    font-style: italic;<br>}<br>code, pre {<br>    font-family: Monaco, Andale Mono, Courier New, monospace;<br>}<br>code {<br>    background-color: #fee9cc;<br>    color: rgba(0, 0, 0, 0.75);<br>    padding: 1px 3px;<br>    font-size: 12px;<br>    -webkit-border-radius: 3px;<br>    -moz-border-radius: 3px;<br>    border-radius: 3px;<br>}<br>pre {<br>    display: block;<br>    padding: 14px;<br>    margin: 0 0 18px;<br>    line-height: 16px;<br>    font-size: 11px;<br>    border: 1px solid #d9d9d9;<br>    white-space: pre-wrap;<br>    word-wrap: break-word;<br>}<br>pre code {<br>    background-color: #fff;<br>    color:#737373;<br>    font-size: 11px;<br>    padding: 0;<br>}<br>sup {<br>    font-size: 0.83em;<br>    vertical-align: super;<br>    line-height: 0;<br>}<br>* {<br>    -webkit-print-color-adjust: exact;<br>}<br>@media screen and (min-width: 914px) {<br>    body {<br>        width: 854px;<br>        margin:10px auto;<br>    }<br>}<br>@media print {<br>    body,code,pre code,h1,h2,h3,h4,h5,h6 {<br>        color: black;<br>    }<br>    table, pre {<br>        page-break-inside: avoid;<br>    }<br>}<br></style><br><title>字节码笔记</title><br><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[[‘$$$’,’$$$’]]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><br></head><br><body><br><h4>字节码笔记</h4><br><br><h6>Structure of JVM</h6><br><br><hr><br><br><p>DataTypes:</p><br><br><ul><br><li><p>primitive types</p><br><br><ul><br><li>Integral Types : int, long, short, char。</li><br><li>Boolean Type : 计算的时候使用int。</li><br><li>Floating-Point Types : float, double。</li><br><li>the returnAddress Type : 开发不能直接使用。</li><br></ul><br></li><br><li><p>reference types</p><br><br><ul><br><li>足够长来存储指针，长度一般与机器位数相同。</li><br></ul><br></li><br></ul><br><br><br><hr><br><br><p>Runtime Data Areas:</p><br><br><ul><br><li><p>The <strong>pc</strong> Register</p><br><br><p>  正常指向指令的地址。</p><br><br><ul><br><li>执行native方法的时候，pc是不存在值的。</li><br></ul><br></li><br><li><p>Java Virtual Machine Stacks</p><br><br><p>  每个线程都有自己的stack，stack存储了frames。</p><br><br><ul><br><li><p>frame</p><br><br><p>  A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p><br><br><p>  A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the Java virtual machine stack (§2.5.2) of the thread creating the frame. Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the runtime constant pool (§2.5.5) of the class of the current method.</p><br><br><ul><br><li><p>Local Variables</p><br><br><p>  一个local variable 占用一个word size；long，double占用两个word size，所以是两个local variable。 0 local variable 为被调用的method所在的object的reference（即this），方法的参数从1 local variable 开始连续 存储。</p><br><br><pre><code>  JVM 设计的word size 不同于 word（8 bits） in computer science：<br><br>  The basic unit of size for data values in the Java virtual machine is the word—a fixed size chosen by the designer of each Java virtual machine implementation. The word size must be large enough to hold a value of type byte, short, int, char, float, returnAddress, or reference. Two words must be large enough to hold a value of type long or double. An implementation designer must therefore choose a word size that is at least 32 bits, but otherwise can pick whatever word size will yield the most efficient implementation. The word size is often chosen to be the size of a native pointer on the host platform.<br></code></pre></li><br><li><p>Operand Stacks</p><br><br><pre><code>  Each frame (§2.6) contains a last-in-first-out (LIFO) stack known as its operand stack.<br></code></pre></li><br><li><p>Dynamic Linking</p><br><br><pre><code>  The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references.<br></code></pre></li><br><li><p>Special Methods</p><br><br><pre><code>  每一个construction都是&lt;init&gt;方法；每一个默认的Void 且没有参数的contruction是&lt;clinit&gt;方法。<br>  they are never invoked directly from any Java virtual machine instruction, but are invoked only indirectly as part of the class initialization process.<br>  signature polymorphic（MethodHandler）这个也是JDK7加入的，为了实现JSR292，为在JVM上实现动态语言提供更多的支持。MethodHandle是JSR292的重要组成部分之一。invokevirtual 指令会对siglenature polymorphic method（MethodHandler以及子类）多特殊处理。<br></code></pre></li><br><li><p>Exception</p><br><br><pre><code>  同步异常（synchronous exception）抛出的方式：<br>  1. athrow 指令的调用<br>  2. JVM相关的Error，类loading，liking阶段相关的Exception，OutOfMemory，StackOverflow，RuntimeException的继承类等。<br>  异步异常（asynchronous exception）抛出的方式：<br>  1. Thread或者ThreadGroup的stop方法被触发。<br>  2. JVM内部的错误<br>      JVM允许异步的异常抛出存在一定的延迟，在最适合的时候记性处理－－在这段延迟中，可以让JVM重排指令来优化代码和计算。（比较简单的实现方式是：在每条[control transfer instruction]执行的时候才去poll异步的异常。正是因为有这个保证，所以control transfer instruction之间的指令能够被JVM优化）<br></code></pre><br><br><p>  在class文件中，excpetion handlers都存在table里面。</p></li><br></ul><br></li><br></ul><br></li><br><li><p>Heap</p><br><br><p>  Heap的管理是通过automacic storage management system，JVMS的实现可以实现自己heap管理机制。</p></li><br><li><p>Method Area</p><br><br><pre><code>It stores per-class structures such as the runtime constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization<br></code></pre><br><br><ul><br><li><p>一般JVMS简单的实现是不会选择去处理Method Area的，但是这个版本的JVMS没有强制要求这么做。</p></li><br><li><p>Runtime Constant Pool</p><br><br><pre><code>  A runtime constant pool is a per-class or per-interface runtime representation of the constant_pool table in a class file (§4.4). It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at runtime. The runtime constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.<br></code></pre></li><br></ul><br></li><br></ul><br><br><br><hr><br><br><p>Instruction Summary:</p><br><br><p>字节码指令流一般是按照字节排列的，只有lookupswitch &amp; tableswitch 比较特别。</p><br><br><ul><br><li><p>instructions with type info:</p><br><br><p>  指令集里面有部分是可以之间看出类型，比如iadd表示可以计算int类型的数据，fadd表示计算float类型的的数据等。但是要每个指令都支持所有的类型，是不现实的，因为一个byte只有8位。所以最后char，boolean，short等的add指令都会被转换成int的计算（使用iadd）。</p></li><br><li><p>instructions regardless of type info:</p><br><br><p>  指令集里面的类似push，pop，swap等是不带type信息的，只关心使用到的category of computational types。</p><br><br><ul><br><li><p>Category 1:</p><br><br><p>  boolean, byte, char, short, int 的计算类型是 int； float计算类型位float；reference为reference；returnAddress为returnAddress；</p></li><br><li><p>Category 2:</p><br><br><p>  long的计算类型为long， double计算类型为double，</p></li><br></ul><br></li><br><li><p>指令概览</p><br><br><ul><br><li><p>支持的类型widening指令（ i2l, i2f, i2d, l2f, l2d, and f2d）：</p><br><br><ul><br><li>int to long, float, or double</li><br><li>long to float or double</li><br><li>float to double</li><br></ul><br></li><br><li><p>支持的narrowing指令（i2b, i2c, i2s, l2i, f2i, f2l, d2i, d2l, and d2f）：</p><br><br><ul><br><li>int to byte, short, or char</li><br><li>long to int</li><br><li>float to int or long</li><br><li>double to int, long, or float</li><br></ul><br></li><br></ul><br><br><br><p>  类型转换过程中，会存在一定的信息丢失情况，具体需要具体翻看了解。</p><br><br><ul><br><li><p>支持的 control transfer instruction 分为以下几类：</p><br><br><ul><br><li><p>conditional branch:</p><br><br><p>  ifeq, ifne, iflt, ifle, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmplt, if_icmple, if_icmpgt if_icmpge, if_acmpeq, if_acmpne</p></li><br><li><p>compound conditional brach:</p><br><br><p>  tableswitch, lookupswitch</p></li><br><li><p>unconditional brach:</p><br><br><p>  goto, goto_w, jsr, jsr_w, ret</p></li><br></ul><br></li><br><li><p>5种方法调用指令：</p><br><br><ul><br><li>invokevirtual: 调用类实例的方法</li><br><li>invokeinterface: ???</li><br><li>invokespecial: init, private, super class的方法</li><br><li>invokestatic: 调用类的方法</li><br><li>invokedynamic: 关联到MethodHandle，看了相关的资料，暂时还没有领会其用途（？？？）</li><br></ul><br></li><br><li><p>同步, 分为两类：</p><br><br><ul><br><li>method synchronization</li><br><li>block synchronization</li><br></ul><br><br><br><p>  moniterenter，moniterexit 这两个指令配合完成同步。</p></li><br></ul><br></li><br></ul><br><br><br><hr><br><br><h6>Compiling for JVM</h6><br><br><p>tableswitch是switch 连续的int 和 lookupswitch是switch离散的int。排序过的switch key 效率更高；tableswitch效率比lookupswitch高。</p><br><br><p>try-catch statements：</p><br><br><pre><code>As a subtle point, note that the range of a catch clause is inclusive on the “from” end and exclusive on the “to” end.<br></code></pre><br><br><p>A Java virtual machine implementation verifies that each class file satisfies the necessary constraints at linking time</p><br><br><p>String.intern() 会找到runtime constant pool中相同字符串的引用地址</p><br><br><p><strong>skip Class file format &amp; Verification of Class Files</strong></p><br><br><hr><br><br><h6>Loading, Linking, and Initializing</h6><br><br><p>VM Start-up</p><br><br><p>调用bootstrap classloader 加载 初始化类，然后加载main方法；一般jvm的实现都有 命令行参数 或者 提供 初始化参数的方式。</p><br><br><p>Creation and Loading</p><br><br><p>C代表一个interface or class;</p><br><br><p>N代表internal name of C in JVM implementation;</p><br><br><p>D触发了C的创建：D的runtime contant pool有C的引用 或者 D通过反射创建C</p><br><br><p>A class loader L may create C by defining it directly or by delegating to another class loader. <strong>If L creates C directly, we say that L defines C or, equivalently, that L is the defining loader of C.</strong></p><br><br><p>When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class. <strong>If L creates C, either by defining it directly or by delegation, we say that L initiates loading of C or, equivalently, that L is an initiating loader of C.</strong></p><br><br><p>The Java virtual machine uses one of three procedures to create class or interface C denoted by N:</p><br><br><ul><br><li><p>If N denotes a nonarray class or an interface, one of the two following methods is used to load and thereby create C:</p><br><br><ul><br><li><p>If D was defined by the bootstrap class loader, then the bootstrap class loader initiates loading of C.</p></li><br><li><p>If D was defined by a user-defined class loader, then that same user-defined class loader initiates loading of C.</p></li><br></ul><br></li><br><li><p>Otherwise N denotes anarray class.An array class is created directly by the Java virtual machine, not by a class loader. However, the defining class loader of D is used in the process of creating array class C.</p></li><br></ul><br><br><br><p>在loading的阶段出现异常，抛出LinkageError的继承类。</p><br><br><p>$$$ &lt;N, L_d&gt; $$$: N denotes the name of the class or interface and $$$ L_d $$$ denotes the defining loader of the class or interface.</p><br><br><p>$$$ N^{L_i} $$$: N denotes the name of the class or interface and $$$ L_i $$$ denotes an initiating loader of the class or interface.</p><br><br><hr><br><br><p>Linking:</p><br><br><p>如果JVM在Verification or Resolution class C的时候抛出了ClassNotFoundException的时候，会被包装成NoClassDefFoundError.（Loading of superclass 是 Rsolution逻辑的一部分）</p><br><br><ul><br><li>Verification</li><br><li>Prepare</li><br><li>Resolusion: 这个可能在真正使用的时候（懒加载，invokedynamic指令）才会使用到；也有情况是直接使用。</li><br></ul><br><br><br><hr><br><br><p>Initializing:</p><br><br><p>ClassLoader.loadClass() 与 Class.forName()<br>ClassLoader.loadClass(String name, boolean resolve)，其中resolve默认为false，即只执行类装载的第一个阶段。</p><br><br><p>Class.forName(String name, boolean initialize, ClassLoader loader)， 其中initialize默认为true，即执行到类装载的第三个阶段。</p><br></body><br></html>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/11/21/理解CPU-steal-time/">
  <time datetime="2015-11-21T06:37:04.000Z">
    11月 21 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/11/21/理解CPU-steal-time/">理解CPU steal time</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Netflix 很关注CPU的Steal Time。他们的策略是：如果是当前虚拟机的Steal Time 超过了你们设置的 阈值，他们会关闭这台虚拟机并且在另外一台物理机上面重启。</p>
<p>如果你想要部署虚拟环境（例如：Amazon EC2）， steal time就是你想要关注的性能指标之一。 如果这个指标的数值很高，那么说明机器状态非常糟糕。什么是steal time？什么会引发高steal time？多少才是警戒值（你需要做什么）？</p>
<h3 id="CPU_Steal_Time_的定义">CPU Steal Time 的定义</h3><p>From <a href="ibm.com">ibm</a>:</p>
<pre><code>Steal <span class="built_in">time</span> is <span class="operator">the</span> percentage <span class="operator">of</span> <span class="built_in">time</span> <span class="operator">a</span> virtual CPU waits <span class="keyword">for</span> <span class="operator">a</span> real CPU <span class="keyword">while</span> <span class="operator">the</span> hypervisor is servicing another virtual processor.
</code></pre><p>你的虚拟机（VM）会与虚拟环境的宿主机上的多个虚拟机实例共享物理资源。其中之一共享的就是CPU时间切片。如果你的VM的物理机虚拟比是1/4， 那么它的CPU使用率不会限制于25%的CPU时间切片－它能够使用超过它设置的虚拟比。（有别于内存的使用，内存大小是严格控制的）。</p>
<h3 id="哪里可以看到CPU_Steal_Time?">哪里可以看到CPU Steal Time?</h3><p>你可以使用Linux 的 TOP 命令来看到实时的一些性能指标。CPU相关的其中一行内容如下：<br><img src="https://dl.dropboxusercontent.com/u/468982/blog/steal/top_steal.png" alt="top"><br>两个你可能较为熟悉的是 %id(空闲 百分比) 和 %wa(I/O 等待 百分比)。 如果 %id 很低， 那么说明CPU的工作负载很大并且没有多少计算负载能力剩余。 如果 %wa 很高，则说明瓶 CPU 处于等待计算的状态，但是正在等待I/O活动的完成(类似 从数据库中获取存储在 磁盘上 的一行数据)。</p>
<p>%st（percent steal time） 是CPU展示的最后一个性能指标。</p>
<h3 id="CPU_Steal_Time_-_类比售票厅">CPU Steal Time - 类比售票厅</h3><p>假设你打算买了若干张最新的好莱坞大片的电影票，且有两条队伍等待买票和一个售票口：</p>
<p><img src="https://dl.dropboxusercontent.com/u/468982/blog/steal/movie_line.png" alt="Movie Theater"></p>
<p>如果我们把 CPU steal time 性能指标 类比成 售票的过程， 那么过程就是如下：</p>
<ul>
<li><p><strong>0% Steal Time</strong> - 现在是礼拜三下午场：售票口正在工作，先处理第一条队伍的电影观众，然后处理第二条，然后第一条，然后第二条，轮流进行。处理的很快，且没有人在等待。</p>
</li>
<li><p><strong>50% Steal Time</strong> - 现在是礼拜五晚上： 在队伍中的一个人有一半的时间需要等待另一个在售票口的人完成卖票，而不能立刻买到票。卖票的时间更长了。</p>
</li>
<li><p><strong>100% Steal Time</strong> - 现在是礼拜五晚上并且 现金出纳金 坏了：所有人都在等待。</p>
</li>
</ul>
<h3 id="为什么高_Steal_Time_会对web应用有更大的影响">为什么高 Steal Time 会对web应用有更大的影响</h3><p>如果有你在负载未满的物理机器上面运行一个长时间的计算任务，那么它可能会使用超过它额定的CPU切片 时间。过一段时间，可能其他的VMs可能也会需要超过它们额定量的CPU切片 时间，所以这个任务的执行会变慢。对于长时间计算任务而言之，这个情况可能并不是不能接受的：它可能是会晚点一完成或者也可能更快的完成（由于它能够使用更多的资源）。</p>
<p>然后，这种情况能够时代web应用停止响应。对于实时任务，类似快速响应许多的web请求，性能下降到1/4会对请求队列执行对应备选逻辑—中断请求。</p>
<h3 id="Steal_Time远高于0的原因">Steal Time远高于0的原因</h3><p>这里有两种可能性：</p>
<ol>
<li><p>你需要一个额定更多CPU资源的虚拟机（你的虚拟机<strong>是</strong>问题）</p>
</li>
<li><p>物理机已经超卖了并且多个虚拟机之间在激烈的竞争资源（你的虚拟机<strong>不是</strong>问题）</p>
</li>
</ol>
<p>提示：<strong>你不能通过看当前被影响的虚拟机实例的CPU性能指标来判断你所遇到的场景。（1 or 2）</strong> 当你有很多的虚拟宿主机上分别都部署了相同职责的服务程序（可能作为集群）时，就比较容易知道自己遇到的问题了。</p>
<p><img src="https://dl.dropboxusercontent.com/u/468982/blog/steal/steal_scenarios.png" alt="资源图片"></p>
<ul>
<li><p>是否 %st(CPU Steal Time Percentage) 在所有机器上面都上涨了？</p>
<p>  这个意味着你的虚拟机在使用更多的CPU资源。你需要为你的虚拟起增加更多的CPU资源的配额。</p>
</li>
<li><p>是否%st(CPU Steal Time Percentage) 只在一部分机器上面陡峭增长？</p>
<p>  这个意味着物理机器被超卖了。把你自己的虚拟机挪到另一个物理机器去吧。</p>
</li>
</ul>
<h3 id="所有，什么时候你应该担心？">所有，什么时候你应该担心？</h3><p>一般的参考标准-<strong>如果steal time 超过了10%并且持续了20分钟，那么虚拟机就可能性能下降了</strong></p>
<p>当这种情况发生：</p>
<ol>
<li><p>关闭虚拟机并且挪到另一台物理机器上面</p>
</li>
<li><p>如果steal time维持在很高的数值， 那么增加CPU资源配额。</p>
</li>
<li><p>如果steal time维持在很高的数值， 联系你的虚拟机提供商。你的虚拟机提供商有可能在超卖物理机。</p>
</li>
</ol>
<p><em>翻译自 <a href="http://blog.scoutapp.com/articles/2013/07/25/understanding-cpu-steal-time-when-should-you-be-worried" target="_blank" rel="external">这里</a></em></p>
<p>公司的应用最近都已经迁移到自家的云计算平台上面了，所以也开始出现了无故Load飙升的情况，最后定位出来原因时虚拟机CPU资源竞争的情况。新知识Get！</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/10/06/亲身经历icloud账号被黑事件/">
  <time datetime="2015-10-06T02:04:00.000Z">
    10月 6 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/10/06/亲身经历icloud账号被黑事件/">亲身经历icloud账号被黑事件</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h3 id="2015-10-05">2015-10-05</h3><p><strong>下午3点</strong>：当时在高速上面聊天，老婆手机被无故重启，重启以后屏幕内容如下：<br>         XXX，如需解锁请在24小时内联系QQ：2075633961</p>
<p><strong>下午4点半</strong>：下高速直奔杭州平海路的apple销售点，找天才吧的技术人员解决，得到答复：他们无法解决，请打4006272273 解决。打了近1个小时的电话，由于换电话号码，忘记提示问题，一直没有成功。</p>
<p><strong>下午6点半</strong>：驱车回家，在家里面打开电脑，这个时候完了，电脑因为使用了同一个appId，也被锁了。老婆明天还要使用电脑办公，如何解决？打电话给4006272273，通过耐心尝试提示问题，终于想起来了2个，解决了icloud的密码问题，icloud账号重新找回了并且修改了密码。手机能够重新激活了，但是数据被抹掉了，算了，大不了，花半个小时重装软件。问题是现在电脑如何解决？还是需要4位的pin码啊。继续4006272273转到mac部门沟通，说是要到实体店售后解决。接着我就电话给实体店售后，售后告诉我不能解决，要4006272273有更高的权限解决。</p>
<pre><code>400热线的客服的让我找实体店技术人员解决，实体店技术人员让我找400热线的客服解决？ 所以这个就是个死循环了？ 这个是什么情况？？？
</code></pre><p>带着不解和火气直奔了苹果的实体店，很理性的询问了技术人员，咨询情况，经过近15分钟的沟通，然后得到的答复是：先要预约，然后要购买凭证，最后电脑的数据会被抹掉。总结下就是：</p>
<pre><code>处理周期是7-15天，然后数据会被抹掉，不能恢复！
</code></pre><p>我心里就明白了：苹果天才吧的技术人员 是 根本不能解决这个问题，然后才和400热线的客服人员进行推脱的！苹果的售后竟然存在如此大的问题，最让人受不了的方式就是这种推诿，浪费消费者的时间和精力。如果早点告诉我们：我们解决不了。我们就会找另外的方案解决了。</p>
<p>最后的结果就是，理性的接受勒索，和对应的QQ ID沟通，支付宝200，然后得到pin码，电脑解锁，保全数据，重装系统，对所有相关邮箱账号都重置了密码和绑定了手机，开启二次验证。icloud账号也开启了二次验证，3天后生效。</p>
<pre><code>虽然icloud账号开启了二次验证，也只是防止被修改密码，如果icloud账号泄露，那么电脑一样可以被锁和抹掉数据！！！
</code></pre><p>总结有两种解决办公电脑不受icloud账号影响的方式：</p>
<ol>
<li>最安全方案：关闭mac上的找回我的mac功能。代价是人肉保证电脑不被偷。</li>
<li>次优方案：软件都使用正版。这种方式最大程度上面减少电脑方面泄露icloud信息，但是不能保证解决icloud相关邮箱和手机icloud信息泄露的情况。</li>
</ol>
<p>小计这件事情的目的：</p>
<ol>
<li>是提醒身边使用mac的朋友，当心icloud账号被人盯上了。</li>
<li>原来apple的售后也是有这么无力的时候，但是却又极力的不想表现出来，让人恶心，基本的诚实也没有。</li>
<li>之前都是听安全部的同事分享黑客和黑产内容，现在算是亲身经历了。2075633961 这个QQ号和他聊天的感觉，看起来是一个专业的客服人员，举报或许有点用吧，现在po一下这个QQ。</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/09/04/本地缓存组件选型/">
  <time datetime="2015-09-04T03:30:53.000Z">
    9月 4 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/09/04/本地缓存组件选型/">本地缓存组件选型</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>需求： 记录系统执行数据，能持久化，容错。</p>
<h2 id="Guava">Guava</h2><p>官网就没有说有persistent的功能，直接略过。</p>
<h2 id="ehcache">ehcache</h2><p>企业版需要缴费，然后持久化功能和保证重启可用的功能都需要缴费。</p>
<p>看看开源版ehcache的是否可以满足，现状是：可以在只是DiskStore相关配置，让cache把内容序列化后直接overflow到文件。<br>现在问题是：</p>
<h4 id="重启">重启</h4><p>重启以后，是重新新建文件并覆盖同名文件—也就是之前同名cache生成的文件。尝试出使用自己实现的RebootCacheLoaderFactory implemets BootstrapCacheLoaderFactory可以来创建 RebootCacheLoader implements BootstrapCacheLoader来实现内容。</p>
<p>RootbootCacheLoaderFactory：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">RebootCacheLoaderFactory</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BootstrapCacheLoaderFactory</span> {</span>
    <span class="annotation">@Override</span>
    public <span class="type">BootstrapCacheLoader</span> createBootstrapCacheLoader(<span class="type">Properties</span> properties) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RebootCacheLoader</span>();
    }
}
</code></pre><p>RebootCacheLoader：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebootCacheLoader</span> <span class="keyword">implements</span> <span class="title">BootstrapCacheLoader</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Ehcache cache)</span> <span class="keyword">throws</span> CacheException </span>{
        cache.put(<span class="keyword">new</span> Element(<span class="string">"haha"</span>+Math.random(), Math.random()));
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsynchronous</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> RebootCacheLoader();
    }
}
</code></pre><p>Main：</p>
<pre><code><span class="typename">String</span> path = <span class="string">"/tmp/ehcache/"</span>;
<span class="typename">String</span> cacheManagerName = <span class="string">"cacheManagerName"</span>;
Long diskSizeBytes = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>L;
<span class="typename">String</span> cache1Name = <span class="string">"40006_1232131231312"</span>;
<span class="typename">String</span> cache2Name = <span class="string">"40002_1232131231312"</span>;

<span class="keyword">Configuration</span> <span class="keyword">configuration</span> = <span class="keyword">new</span> <span class="keyword">Configuration</span>();
<span class="keyword">configuration</span>.setName(cacheManagerName);
CacheConfiguration defaultCacheConfiguration = <span class="keyword">new</span> CacheConfiguration();
defaultCacheConfiguration.overflowToOffHeap(false);
defaultCacheConfiguration.overflowToDisk(true);
defaultCacheConfiguration.maxEntriesLocalHeap(<span class="number">1</span>); //<span class="number">0</span> <span class="keyword">is</span> <span class="keyword">not</span> limited, DiskStore, MemStore will <span class="keyword">all</span> have the element; <span class="number">1</span> means just the last element will be <span class="keyword">in</span> memory.
defaultCacheConfiguration.maxBytesLocalDisk(<span class="number">2</span>, MemoryUnit.MEGABYTES); //模糊的界定，异步写入，主线程结束了，还有一些记录没有记录的，会丢失数据。
defaultCacheConfiguration.addBootstrapCacheLoaderFactory(<span class="keyword">new</span> CacheConfiguration.BootstrapCacheLoaderFactoryConfiguration().className(
            <span class="string">"com.daniel.test.RebootCacheLoaderFactory"</span>
    ));

<span class="keyword">configuration</span>.setDefaultCacheConfiguration(defaultCacheConfiguration);

CacheManager cacheManager = <span class="keyword">new</span> CacheManager(<span class="keyword">configuration</span>);

cacheManager.addCache(cache1Name);
</code></pre><p>在<strong>cacheManager.addCache(cache1Name)</strong>方法里面clone一个defaultCache，然后改个名字，然后initialize cache完成之后，调用cache.bootstrap()方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">bootstrap</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (!disabled &amp;&amp; bootstrapCacheLoader != <span class="keyword">null</span>) {
        bootstrapCacheLoader.load(<span class="keyword">this</span>);
    }

}
</code></pre><p>然后就可以load到自定义信息了，因为底层就是用了java自带序列化来存储Element对象，方法在：<strong>DiskStorageFactory.serializeElement()</strong></p>
<h3 id="持久化">持久化</h3><p>从最近本的cache.put()方法不断debug进去，发现DiskStore.put()引用了segment.put()，然后Element的行记录的包装类PlaceHolder里面的install方法调用了如下内容：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">installed</span><span class="params">()</span> </span>{
    DiskStorageFactory.<span class="keyword">this</span>.schedule(<span class="keyword">new</span> PersistentDiskWriteTask(<span class="keyword">this</span>));
}
</code></pre><p>看着感觉很悲剧，果然看到里面是一个ScheduledThreadPoolExecutor在执行，实体是DiskStorageFactory里面的diskWriter，然后是默认生成的，还不能修改队列啥的：</p>
<pre><code>diskWriter <span class="subst">=</span> <span class="literal">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="literal">new</span> ThreadFactory() {
    <span class="keyword">public</span> <span class="keyword">Thread</span> newThread(Runnable r) {
        <span class="keyword">Thread</span> t <span class="subst">=</span> <span class="literal">new</span> <span class="keyword">Thread</span>(r, file<span class="built_in">.</span>getName());
        t<span class="built_in">.</span>setDaemon(<span class="literal">false</span>);
        <span class="keyword">return</span> t;
    }
});
</code></pre><p>这个构造函数，消息队列是默认11个的PriorityQueue，所以机器中断可能导致数据还在queue里面没被写入到磁盘。这个组件不能用了！！！</p>
<h2 id="OSCache">OSCache</h2><p>名声挺好的，搜了下，已经不维护了，略过</p>
<h2 id="JCS">JCS</h2><p>JCS是插件式管看着很棒，persistent功能介绍也很强大，符合我的需求，看了一眼bugfix清单，关于persistet的bug那么多，最新的版本还是beta的，完全不敢用，不想自找麻烦。</p>
<h2 id="FQueue">FQueue</h2><p>转换下思路了。如果说持久化要做到可靠性最佳，理论上面就应该是同步插入数据到磁盘；如果还要保证消费的顺序性，想了一种方案，如下:</p>
<p><img src="http://7oxfl2.com1.z0.glb.clouddn.com/思路.jpg" alt="思路">：</p>
<p>虽然很开心的想出来了，但是可靠性却不能保证啊。我们的存储使用的是HBASE，scheme设计是：rowkey用index，所有相同index的记录都需要记录到一行记录里面。如果我再搞一个持久化的重试队列，Queue的Element先poll出来，push到retryQueue extends LinkedList，并在内存存储retryQueue的Element和位置的关系Map，然后等异步插入HBase数据完成之后，利用内存关系来做删除，这个时候有两个问题：</p>
<ol>
<li><p>fQueue使用是FIFO的Queue，如何在记录位置并删除呢，效率是否有影响？想象下多个线程同时操作一个文件。如果要做, 可能需要学ehcache的方式，在内存里面映射文件为一个map，做segment分段加锁，然后在内存中删除，同时交给一个只有一个线程的线程池异步删除对应文件数据，那这样最多就2个线程抢占一个文件，一个写入，一个删除；那么问题来了，因为是异步，所以可能存在crash的时候内存删除了，文件数据没删除的情况，对异常恢复造成影响，类似之后提到的2问题。</p>
</li>
<li><p>插入HBase的时候，机器crash了，我们不知道是否真的插入成功了，就需要在机器重启的时候重新插入，这个时候会在同一行记录里面append内容一样的column了。</p>
</li>
</ol>
<p>换一种思路：<br>我每一个index下的内容都生成一个持久化文件，并在内存中存储一个mark标记，标记是否index文件生成完了，监听器监听 <strong>生成完</strong>的状态，然后交给一个线程处理这个index相关的一个文件，因为内容是顺序的，所以直接拼装成一条记录，并且写入，写入成功之后，删除这个index对应的文件。异常状况处理如下：</p>
<ol>
<li><p>index下内容生成一半，crash，重启以后首先消费掉这些数据并做插入到HBase，保证异常数据也能够被系统得到。</p>
</li>
<li><p>插入HBase时，crash，重启以后同样重复消费文件数据，构造一条记录，插入。如果上次已经插入通用的rowkey数据，那么HBase自己会做update，那么业务上面完全没有影响，就是DB方面多update了一次。</p>
</li>
</ol>
<p>恩，现在感觉完美了。</p>
<p>FQueue默认文件大小是300M，用400个线程同时创建文件，ssd 硬盘，2.5GCPU的配置直接卡爆。然后调整为默认为1M。重写了三个类：FQueue.java, FSQueue.java, LogEntity.java</p>
<p>HMFQueue.java</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">HMFQueue</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>{
    fsQueue = <span class="keyword">new</span> HMFSQueue(path, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>); <span class="comment">//默认是1M大小</span>
}

<span class="annotation">@Override</span>
<span class="comment">//not thread safe, be careful , 添加了iterator的支持，需要修改FSQueue和LogEntity</span>
<span class="keyword">public</span> Iterator&lt;<span class="keyword">byte</span>[]&gt; iterator() {
    <span class="keyword">try</span> {
        fsQueue.curseToHead();
    } <span class="keyword">catch</span> (IOException e) {
        log.<span class="keyword">error</span>(<span class="string">" cannot open the file!"</span>,e );
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"failed to move to head!"</span>);
    } <span class="keyword">catch</span> (FileFormatException e) {
        log.<span class="keyword">error</span>(<span class="string">"failed to move to head! the file format is wrong"</span>,e );
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"failed to move to head!"</span>);
    }

    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;<span class="keyword">byte</span>[]&gt;() {

        <span class="annotation">@Override</span>
         <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{
            <span class="function"><span class="keyword">return</span> fsQueue.<span class="title">hasNext</span><span class="params">()</span></span>;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">byte</span>[] next() {
            <span class="function"><span class="keyword">return</span> fsQueue.<span class="title">readNextAndMove</span><span class="params">()</span></span>;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{
            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove operation is not supported here!"</span>);
        }
    };
}
</code></pre><p>HMFSQueue.java 添加如下方法支持文件的重头读取和遍历</p>
<pre><code><span class="comment">//not thread safe 定位到文件的头部，更新index</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">curseToHead</span><span class="params">()</span>  <span class="keyword">throws</span> IOException, FileFormatException </span>{
    <span class="keyword">int</span> fileNum = -<span class="number">1</span>;
    File dir = <span class="keyword">new</span> File(path);
    <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory()){
        <span class="keyword">if</span>(dir.listFiles() != <span class="keyword">null</span> &amp;&amp; dir.listFiles().length &gt; <span class="number">0</span>){
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Integer.MAX_VALUE; i++){
                String fileName = path + fileSeparator + filePrefix + <span class="string">"data_"</span> + i + <span class="string">".idb"</span>;
                File file = <span class="keyword">new</span> File(fileName);
                <span class="keyword">if</span>(file.exists()){
                    fileNum = i;
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span>(fileNum != -<span class="number">1</span>){
                <span class="keyword">if</span> (writerHandle.getCurrentFileNumber() == fileNum) {
                    readerHandle = writerHandle;
                }<span class="keyword">else</span>{
                    readerHandle = createLogEntity(path + fileSeparator + filePrefix + <span class="string">"data_"</span> + fileNum + <span class="string">".idb"</span>, db,
                            fileNum);
                }
                readerHandle.resetReaderPosition();
            }
        }
    }
}

<span class="comment">//not thread safe 判断是否有下一条数据</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>{
    <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        b = readerHandle.readNext();
    } <span class="keyword">catch</span> (FileEOFException e) {
        <span class="keyword">int</span> nextfile = readerHandle.getNextFile();
        readerHandle.close();
        <span class="comment">// 更新下一次读取的位置和索引</span>
        db.putReaderPosition(HMLogEntity.messageStartPosition);
        db.putReaderIndex(nextfile);
        <span class="keyword">if</span> (writerHandle.getCurrentFileNumber() == nextfile) {
            readerHandle = writerHandle;
        } <span class="keyword">else</span> {
            <span class="keyword">try</span> {
                readerHandle = createLogEntity(path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, db,
                        nextfile);
            } <span class="keyword">catch</span> (IOException e1) {
                log.<span class="keyword">error</span>(<span class="string">"failed to read file: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>,e1);
            } <span class="keyword">catch</span> (FileFormatException e1) {
                log.<span class="keyword">error</span>(<span class="string">"the file has wrong format: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, e1);
            }
        }
        <span class="keyword">try</span> {
            b = readerHandle.readNext();
        } <span class="keyword">catch</span> (FileEOFException e1) {
            log.<span class="keyword">error</span>(<span class="string">"read new log file FileEOFException error occurred"</span>,e1);
        }
    }
    <span class="keyword">if</span> (b != <span class="keyword">null</span>) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="comment">//not thread safe 读取下一个并且更新索引</span>
<span class="keyword">public</span> <span class="keyword">byte</span>[] readNextAndMove(){
    <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        b = readerHandle.readNextAndMove();
    } <span class="keyword">catch</span> (FileEOFException e) {
        <span class="keyword">int</span> nextfile = readerHandle.getNextFile();
        readerHandle.close();
        <span class="comment">// 更新下一次读取的位置和索引</span>
        db.putReaderPosition(HMLogEntity.messageStartPosition);
        db.putReaderIndex(nextfile);
        <span class="keyword">if</span> (writerHandle.getCurrentFileNumber() == nextfile) {
            readerHandle = writerHandle;
        } <span class="keyword">else</span> {
            <span class="keyword">try</span> {
                readerHandle = createLogEntity(path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, db,
                        nextfile);
            } <span class="keyword">catch</span> (IOException e1) {
                log.<span class="keyword">error</span>(<span class="string">"failed to read file: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, e1);
            } <span class="keyword">catch</span> (FileFormatException e1) {
                log.<span class="keyword">error</span>(<span class="string">"the file has wrong format: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, e1);
            }
        }
        <span class="keyword">try</span> {
            b = readerHandle.readNextAndMove();
        } <span class="keyword">catch</span> (FileEOFException e1) {
            log.<span class="keyword">error</span>(<span class="string">"read new log file FileEOFException error occurred"</span>,e1);
        }
    }
    <span class="keyword">return</span> b;
}

<span class="comment">//删除消息队列相关数据文件</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">delQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileFormatException </span>{
    FileUtils.deleteDirectory(<span class="keyword">new</span> File(path));
}
</code></pre><p>HMLogEntity.java</p>
<pre><code><span class="keyword">public</span> HMLogEntity(<span class="built_in">String</span> path, LogIndex db, int fileNumber,
                 int fileLimitLength) throws IOException, FileFormatException {
    <span class="attribute">...</span><span class="attribute">...</span><span class="built_in">..
    </span><span class="keyword">if</span> (file<span class="built_in">.</span>exists() <span class="subst">==</span> <span class="literal">false</span>) {
        createLogEntity();
        <span class="comment">//FileRunner.addCreateFile(Integer.toString(fileNumber + 1)); //注释掉，如果文件切片为1M时候，提前创建有问题：由于是异步的，消费的时候会存在还没有创建成功，写入失败的情况。</span>
    } <span class="keyword">else</span> {
        <span class="attribute">...</span><span class="attribute">...</span><span class="built_in">..
    </span>}      
}
</code></pre><p>测试下性能，单线程写20W的数据花了9s；</p>
<p>但是多线程写入多个文件性能和稳定性可能有问题了：</p>
<ol>
<li><p>400个线程，每个线程创建自己的文件，写入300条数据，遍历300条数据，删除自己创建写入的文件总共要6.1s，且一切正常。</p>
</li>
<li><p>400个线程，每个线程创建自己的文件，写入400条数据，遍历400条数据，删除自己创建写入的文件出现写入失败和读取失败的情况：240个线程写入完成，133个线程遍历完成，且没有异常抛出。</p>
</li>
<li><p>600个线程，每个线程创建自己的文件，写入300条数据，遍历300条数据，删除自己创建写入的文件出现写入失败和读取失败的情况：244个线程写入完成，160个线程遍历完成，且没有异常抛出。</p>
</li>
</ol>
<p>1的情况已经是达到了临界值。2，3都会出现不稳定的情况，我去，这个是啥原因呢？？百思不得其解。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/04/09/Dynamic-Bean/">
  <time datetime="2015-04-09T02:19:28.000Z">
    4月 9 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/04/09/Dynamic-Bean/">Dynamic Bean</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>突然对一些基础类库的代码感了兴趣，于是最先看起了Apache的commons-beanutils这个包，然后顺藤摸瓜式的了解JavaBeans和Dynamic Bean相关的知识。</p>
<h3 id="common-beanutils-1-9-2">common-beanutils-1.9.2</h3><p>此包主要功能如下：</p>
<pre><code>创建动态的JavaBean及相关的util类型代码。
</code></pre><p>主要类的关系图如下：</p>
<p><img src="http://tempwork.qiniudn.com/apache-beanutils-class-diagram.jpg" alt="主要类图" title="Title"></p>
<ul>
<li><p>DynaClass, DynaProperty, DynaBean用来动态生成JavaBean, 主要使用了Java的原生包：java.lang.reflect &amp; java.beans</p>
</li>
<li><p>BeanUtilsBean是单例, 包含拷贝属性，克隆bean等util方法。</p>
</li>
</ul>
<p>举个<a href="http://www.javadb.com/simple-dynabean-example-apache-commons-beanutils/" title="beanutils实践例子" target="_blank" rel="external">栗子</a>：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.BasicDynaClass;</span>
<span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.DynaBean;</span>
<span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.DynaClass;</span>
<span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.DynaProperty;</span>

<span class="comment">/**
 *
  * @author www.javadb.com
  */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynaBeanExample</span> </span>{

    <span class="keyword">private</span> <span class="keyword">final</span> String NR_OF_WHEELS = <span class="string">"numberOfWheels"</span>;

    <span class="keyword">private</span> <span class="keyword">void</span> runExample() {

        DynaClass dynaClass = <span class="keyword">new</span> BasicDynaClass(<span class="string">"Car"</span>, <span class="literal">null</span>,
            <span class="keyword">new</span> DynaProperty[]{
                <span class="keyword">new</span> DynaProperty(NR_OF_WHEELS, Integer.TYPE)});

        <span class="keyword">try</span> {
            DynaBean car = dynaClass.newInstance();
            car.<span class="keyword">set</span>(NR_OF_WHEELS, <span class="number">4</span>);

               System.out.println(<span class="string">"Number of wheels: "</span> + car.<span class="keyword">get</span>(NR_OF_WHEELS));

            System.out.println(<span class="string">"DynaBean is instance of DynaClass: "</span> + car.getDynaClass().getName());

        } <span class="keyword">catch</span> (IllegalAccessException | InstantiationException ex) {
            System.err.println(ex.getMessage());
        }
    }

   <span class="comment">/**
     * @param args the command line arguments
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        DynaBeanExample ac = <span class="keyword">new</span> DynaBeanExample();
        ac.runExample();
    }
}
</code></pre><p>所以看着这个使用的方式感觉还是蛮有意思的，可以动态的生成自己想要的<em>“Java Bean”</em>。</p>
<p>这个时候就开始好奇这个包会有什么问题呢？比如性能上面？然后就搜到了<a href="http://blog.athico.com/2006/11/just-say-no-to-dynabeans.html" title="反对使用beanutils包" target="_blank" rel="external">这个</a>。<strong>Drools</strong>很早就开始反对使用这种方式来构建<strong>Java Bean</strong>，理由很简单，系统兼容性不好，说这个包虽然实现的<strong>Dynamic Bean</strong>的功能，但是生成的DynaBean是不符合<strong>JavaBeans</strong>的规范的，将会引发一系列的代码兼容性的问题，所以不建议商业系统环境使用这个包—例如主流的ORM框架都只支持规范的<strong>JavaBeans</strong>。我们看代码可以发现<code>DynaBean</code>使用的是一个<code>Map&lt;String, DynaProperty&gt;</code>来存储属性的。</p>
<p>那么现在问题来了，什么是<strong>JavaBeans</strong> ?</p>
<h3 id="JavaBean">JavaBean</h3><p>参阅<a href="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/" target="_blank" rel="external">JavaBeans(TM) Specification</a>官方的文档，移步<a href="http://melody-dc.com/2015/04/09/JavaBeans-TM/" target="_blank" rel="external">解读大纲</a>。所以这个包是通过使用Introspection相关的类来实现<strong>Dynamic Bean</strong>，而不是构造符合<strong>JavaBeans</strong>规范的类.所以<strong>Drools</strong>就推荐使用了cglib来实现<strong>Dynamic Bean</strong>, 移步此<a href="http://sixlegs.com/blog/java/death-to-dynabeans.html" target="_blank" rel="external">参考</a>。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/04/09/JavaBeans-TM/">
  <time datetime="2015-04-09T02:12:55.000Z">
    4月 9 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/04/09/JavaBeans-TM/">JavaBeans(TM)</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>JavaBeans是为了定义出最小的可复用的组件，具备移植性和复用性，类似com+组件。</p>
<p>Java Bean由properties，event，method(listen methods)组成。</p>
<p>JavaBeans定义了一堆规范和利用了listener design pattern来完成properties变化事件和自定义事件的监听。</p>
<p><img src="http://tempwork.qiniudn.com/beans.jpg" alt="JavaBeans交互图"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/03/24/hello-world/">
  <time datetime="2015-03-24T02:16:39.000Z">
    3月 24 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/03/24/hello-world/">Hello World</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2063207" charset="utf-8"></script>
<!-- JiaThis Button END -->



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2015 <a href="/">danielding</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'danielding' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>