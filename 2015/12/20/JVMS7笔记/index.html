<p>&lt;!doctype html&gt;</p>
<html><br><head><br><meta charset="utf-8"><br><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"><br><style><br>h1,<br>h2,<br>h3,<br>h4,<br>h5,<br>h6,<br>p,<br>blockquote {<br>    margin: 0;<br>    padding: 0;<br>}<br>body {<br>    font-family: “Helvetica Neue”, Helvetica, “Hiragino Sans GB”, Arial, sans-serif;<br>    font-size: 13px;<br>    line-height: 18px;<br>    color: #737373;<br>    background-color: white;<br>    margin: 10px 13px 10px 13px;<br>}<br>table {<br>    margin: 10px 0 15px 0;<br>    border-collapse: collapse;<br>}<br>td,th {<br>    border: 1px solid #ddd;<br>    padding: 3px 10px;<br>}<br>th {<br>    padding: 5px 10px;<br>}<br><br>a {<br>    color: #0069d6;<br>}<br>a:hover {<br>    color: #0050a3;<br>    text-decoration: none;<br>}<br>a img {<br>    border: none;<br>}<br>p {<br>    margin-bottom: 9px;<br>}<br>h1,<br>h2,<br>h3,<br>h4,<br>h5,<br>h6 {<br>    color: #404040;<br>    line-height: 36px;<br>}<br>h1 {<br>    margin-bottom: 18px;<br>    font-size: 30px;<br>}<br>h2 {<br>    font-size: 24px;<br>}<br>h3 {<br>    font-size: 18px;<br>}<br>h4 {<br>    font-size: 16px;<br>}<br>h5 {<br>    font-size: 14px;<br>}<br>h6 {<br>    font-size: 13px;<br>}<br>hr {<br>    margin: 0 0 19px;<br>    border: 0;<br>    border-bottom: 1px solid #ccc;<br>}<br>blockquote {<br>    padding: 13px 13px 21px 15px;<br>    margin-bottom: 18px;<br>    font-family:georgia,serif;<br>    font-style: italic;<br>}<br>blockquote:before {<br>    content:”\201C”;<br>    font-size:40px;<br>    margin-left:-10px;<br>    font-family:georgia,serif;<br>    color:#eee;<br>}<br>blockquote p {<br>    font-size: 14px;<br>    font-weight: 300;<br>    line-height: 18px;<br>    margin-bottom: 0;<br>    font-style: italic;<br>}<br>code, pre {<br>    font-family: Monaco, Andale Mono, Courier New, monospace;<br>}<br>code {<br>    background-color: #fee9cc;<br>    color: rgba(0, 0, 0, 0.75);<br>    padding: 1px 3px;<br>    font-size: 12px;<br>    -webkit-border-radius: 3px;<br>    -moz-border-radius: 3px;<br>    border-radius: 3px;<br>}<br>pre {<br>    display: block;<br>    padding: 14px;<br>    margin: 0 0 18px;<br>    line-height: 16px;<br>    font-size: 11px;<br>    border: 1px solid #d9d9d9;<br>    white-space: pre-wrap;<br>    word-wrap: break-word;<br>}<br>pre code {<br>    background-color: #fff;<br>    color:#737373;<br>    font-size: 11px;<br>    padding: 0;<br>}<br>sup {<br>    font-size: 0.83em;<br>    vertical-align: super;<br>    line-height: 0;<br>}<br>* {<br>    -webkit-print-color-adjust: exact;<br>}<br>@media screen and (min-width: 914px) {<br>    body {<br>        width: 854px;<br>        margin:10px auto;<br>    }<br>}<br>@media print {<br>    body,code,pre code,h1,h2,h3,h4,h5,h6 {<br>        color: black;<br>    }<br>    table, pre {<br>        page-break-inside: avoid;<br>    }<br>}<br></style><br><title>字节码笔记</title><br><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[[‘$$$’,’$$$’]]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><br></head><br><body><br><h4>字节码笔记</h4><br><br><h6>Structure of JVM</h6><br><br><hr><br><br><p>DataTypes:</p><br><br><ul><br><li><p>primitive types</p><br><br><ul><br><li>Integral Types : int, long, short, char。</li><br><li>Boolean Type : 计算的时候使用int。</li><br><li>Floating-Point Types : float, double。</li><br><li>the returnAddress Type : 开发不能直接使用。</li><br></ul><br></li><br><li><p>reference types</p><br><br><ul><br><li>足够长来存储指针，长度一般与机器位数相同。</li><br></ul><br></li><br></ul><br><br><br><hr><br><br><p>Runtime Data Areas:</p><br><br><ul><br><li><p>The <strong>pc</strong> Register</p><br><br><p>  正常指向指令的地址。</p><br><br><ul><br><li>执行native方法的时候，pc是不存在值的。</li><br></ul><br></li><br><li><p>Java Virtual Machine Stacks</p><br><br><p>  每个线程都有自己的stack，stack存储了frames。</p><br><br><ul><br><li><p>frame</p><br><br><p>  A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p><br><br><p>  A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the Java virtual machine stack (§2.5.2) of the thread creating the frame. Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the runtime constant pool (§2.5.5) of the class of the current method.</p><br><br><ul><br><li><p>Local Variables</p><br><br><p>  一个local variable 占用一个word size；long，double占用两个word size，所以是两个local variable。 0 local variable 为被调用的method所在的object的reference（即this），方法的参数从1 local variable 开始连续 存储。</p><br><br><pre><code>  JVM 设计的word size 不同于 word（8 bits） in computer science：<br><br>  The basic unit of size for data values in the Java virtual machine is the word—a fixed size chosen by the designer of each Java virtual machine implementation. The word size must be large enough to hold a value of type byte, short, int, char, float, returnAddress, or reference. Two words must be large enough to hold a value of type long or double. An implementation designer must therefore choose a word size that is at least 32 bits, but otherwise can pick whatever word size will yield the most efficient implementation. The word size is often chosen to be the size of a native pointer on the host platform.<br></code></pre></li><br><li><p>Operand Stacks</p><br><br><pre><code>  Each frame (§2.6) contains a last-in-first-out (LIFO) stack known as its operand stack.<br></code></pre></li><br><li><p>Dynamic Linking</p><br><br><pre><code>  The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references.<br></code></pre></li><br><li><p>Special Methods</p><br><br><pre><code>  每一个construction都是&lt;init&gt;方法；每一个默认的Void 且没有参数的contruction是&lt;clinit&gt;方法。<br>  they are never invoked directly from any Java virtual machine instruction, but are invoked only indirectly as part of the class initialization process.<br>  signature polymorphic（MethodHandler）这个也是JDK7加入的，为了实现JSR292，为在JVM上实现动态语言提供更多的支持。MethodHandle是JSR292的重要组成部分之一。invokevirtual 指令会对siglenature polymorphic method（MethodHandler以及子类）多特殊处理。<br></code></pre></li><br><li><p>Exception</p><br><br><pre><code>  同步异常（synchronous exception）抛出的方式：<br>  1. athrow 指令的调用<br>  2. JVM相关的Error，类loading，liking阶段相关的Exception，OutOfMemory，StackOverflow，RuntimeException的继承类等。<br>  异步异常（asynchronous exception）抛出的方式：<br>  1. Thread或者ThreadGroup的stop方法被触发。<br>  2. JVM内部的错误<br>      JVM允许异步的异常抛出存在一定的延迟，在最适合的时候记性处理－－在这段延迟中，可以让JVM重排指令来优化代码和计算。（比较简单的实现方式是：在每条[control transfer instruction]执行的时候才去poll异步的异常。正是因为有这个保证，所以control transfer instruction之间的指令能够被JVM优化）<br></code></pre><br><br><p>  在class文件中，excpetion handlers都存在table里面。</p></li><br></ul><br></li><br></ul><br></li><br><li><p>Heap</p><br><br><p>  Heap的管理是通过automacic storage management system，JVMS的实现可以实现自己heap管理机制。</p></li><br><li><p>Method Area</p><br><br><pre><code>It stores per-class structures such as the runtime constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization<br></code></pre><br><br><ul><br><li><p>一般JVMS简单的实现是不会选择去处理Method Area的，但是这个版本的JVMS没有强制要求这么做。</p></li><br><li><p>Runtime Constant Pool</p><br><br><pre><code>  A runtime constant pool is a per-class or per-interface runtime representation of the constant_pool table in a class file (§4.4). It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at runtime. The runtime constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.<br></code></pre></li><br></ul><br></li><br></ul><br><br><br><hr><br><br><p>Instruction Summary:</p><br><br><p>字节码指令流一般是按照字节排列的，只有lookupswitch &amp; tableswitch 比较特别。</p><br><br><ul><br><li><p>instructions with type info:</p><br><br><p>  指令集里面有部分是可以之间看出类型，比如iadd表示可以计算int类型的数据，fadd表示计算float类型的的数据等。但是要每个指令都支持所有的类型，是不现实的，因为一个byte只有8位。所以最后char，boolean，short等的add指令都会被转换成int的计算（使用iadd）。</p></li><br><li><p>instructions regardless of type info:</p><br><br><p>  指令集里面的类似push，pop，swap等是不带type信息的，只关心使用到的category of computational types。</p><br><br><ul><br><li><p>Category 1:</p><br><br><p>  boolean, byte, char, short, int 的计算类型是 int； float计算类型位float；reference为reference；returnAddress为returnAddress；</p></li><br><li><p>Category 2:</p><br><br><p>  long的计算类型为long， double计算类型为double，</p></li><br></ul><br></li><br><li><p>指令概览</p><br><br><ul><br><li><p>支持的类型widening指令（ i2l, i2f, i2d, l2f, l2d, and f2d）：</p><br><br><ul><br><li>int to long, float, or double</li><br><li>long to float or double</li><br><li>float to double</li><br></ul><br></li><br><li><p>支持的narrowing指令（i2b, i2c, i2s, l2i, f2i, f2l, d2i, d2l, and d2f）：</p><br><br><ul><br><li>int to byte, short, or char</li><br><li>long to int</li><br><li>float to int or long</li><br><li>double to int, long, or float</li><br></ul><br></li><br></ul><br><br><br><p>  类型转换过程中，会存在一定的信息丢失情况，具体需要具体翻看了解。</p><br><br><ul><br><li><p>支持的 control transfer instruction 分为以下几类：</p><br><br><ul><br><li><p>conditional branch:</p><br><br><p>  ifeq, ifne, iflt, ifle, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmplt, if_icmple, if_icmpgt if_icmpge, if_acmpeq, if_acmpne</p></li><br><li><p>compound conditional brach:</p><br><br><p>  tableswitch, lookupswitch</p></li><br><li><p>unconditional brach:</p><br><br><p>  goto, goto_w, jsr, jsr_w, ret</p></li><br></ul><br></li><br><li><p>5种方法调用指令：</p><br><br><ul><br><li>invokevirtual: 调用类实例的方法</li><br><li>invokeinterface: ???</li><br><li>invokespecial: init, private, super class的方法</li><br><li>invokestatic: 调用类的方法</li><br><li>invokedynamic: 关联到MethodHandle，看了相关的资料，暂时还没有领会其用途（？？？）</li><br></ul><br></li><br><li><p>同步, 分为两类：</p><br><br><ul><br><li>method synchronization</li><br><li>block synchronization</li><br></ul><br><br><br><p>  moniterenter，moniterexit 这两个指令配合完成同步。</p></li><br></ul><br></li><br></ul><br><br><br><hr><br><br><h6>Compiling for JVM</h6><br><br><p>tableswitch是switch 连续的int 和 lookupswitch是switch离散的int。排序过的switch key 效率更高；tableswitch效率比lookupswitch高。</p><br><br><p>try-catch statements：</p><br><br><pre><code>As a subtle point, note that the range of a catch clause is inclusive on the “from” end and exclusive on the “to” end.<br></code></pre><br><br><p>A Java virtual machine implementation verifies that each class file satisfies the necessary constraints at linking time</p><br><br><p>String.intern() 会找到runtime constant pool中相同字符串的引用地址</p><br><br><p><strong>skip Class file format &amp; Verification of Class Files</strong></p><br><br><hr><br><br><h6>Loading, Linking, and Initializing</h6><br><br><p>VM Start-up</p><br><br><p>调用bootstrap classloader 加载 初始化类，然后加载main方法；一般jvm的实现都有 命令行参数 或者 提供 初始化参数的方式。</p><br><br><p>Creation and Loading</p><br><br><p>C代表一个interface or class;</p><br><br><p>N代表internal name of C in JVM implementation;</p><br><br><p>D触发了C的创建：D的runtime contant pool有C的引用 或者 D通过反射创建C</p><br><br><p>A class loader L may create C by defining it directly or by delegating to another class loader. <strong>If L creates C directly, we say that L defines C or, equivalently, that L is the defining loader of C.</strong></p><br><br><p>When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class. <strong>If L creates C, either by defining it directly or by delegation, we say that L initiates loading of C or, equivalently, that L is an initiating loader of C.</strong></p><br><br><p>The Java virtual machine uses one of three procedures to create class or interface C denoted by N:</p><br><br><ul><br><li><p>If N denotes a nonarray class or an interface, one of the two following methods is used to load and thereby create C:</p><br><br><ul><br><li><p>If D was defined by the bootstrap class loader, then the bootstrap class loader initiates loading of C.</p></li><br><li><p>If D was defined by a user-defined class loader, then that same user-defined class loader initiates loading of C.</p></li><br></ul><br></li><br><li><p>Otherwise N denotes anarray class.An array class is created directly by the Java virtual machine, not by a class loader. However, the defining class loader of D is used in the process of creating array class C.</p></li><br></ul><br><br><br><p>在loading的阶段出现异常，抛出LinkageError的继承类。</p><br><br><p>$$$ &lt;N, L_d&gt; $$$: N denotes the name of the class or interface and $$$ L_d $$$ denotes the defining loader of the class or interface.</p><br><br><p>$$$ N^{L_i} $$$: N denotes the name of the class or interface and $$$ L_i $$$ denotes an initiating loader of the class or interface.</p><br><br><hr><br><br><p>Linking:</p><br><br><p>如果JVM在Verification or Resolution class C的时候抛出了ClassNotFoundException的时候，会被包装成NoClassDefFoundError.（Loading of superclass 是 Rsolution逻辑的一部分）</p><br><br><ul><br><li>Verification</li><br><li>Prepare</li><br><li>Resolusion: 这个可能在真正使用的时候（懒加载，invokedynamic指令）才会使用到；也有情况是直接使用。</li><br></ul><br><br><br><hr><br><br><p>Initializing:</p><br><br><p>ClassLoader.loadClass() 与 Class.forName()<br>ClassLoader.loadClass(String name, boolean resolve)，其中resolve默认为false，即只执行类装载的第一个阶段。</p><br><br><p>Class.forName(String name, boolean initialize, ClassLoader loader)， 其中initialize默认为true，即执行到类装载的第三个阶段。</p><br></body><br></html>
