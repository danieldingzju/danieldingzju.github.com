
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>磐石</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="danielding&apos;s blog | java | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="磐石">
<meta property="og:url" content="https://danieldingzju.github.io/index.html">
<meta property="og:site_name" content="磐石">
<meta property="og:description" content="danielding&apos;s blog | java | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="磐石">
<meta name="twitter:description" content="danielding&apos;s blog | java | bi">
  
    <link rel="alternative" href="/atom.xml" title="磐石" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">磐石</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">工程狮</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="danieldingzju.github.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-taobao-tomcat类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/30/taobao-tomcat类加载机制/" class="article-date">
  <time datetime="2016-01-29T16:18:21.000Z" itemprop="datePublished">1月 30 2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/taobao-tomcat类加载机制/">taobao-tomcat类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于项目的需要，需要分析下公司内一般web应用的类加载情况，于是翻了翻taobao-tomcat的源码，和pandora相关源码。</p>
<p>一般tomcat机制参考：<a href="http://melody-dc.com/2016/01/29/%E5%BC%80%E6%BA%90tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">经典tomcat类加载机制</a></p>
<p>公司的tomcat类加载机制如下：</p>
<p><img src="http://tempwork.qiniudn.com/taobao-tomcat.jpg" alt="taobao-tomcat"></p>
<p>PandoraDeployment初始化了自己的pandoraClassLoader，然后启动了container。</p>
<p><strong>TomcatWebAppLoader</strong>构建自己和pandoraClassLoader的关系，然后导出pandora中的类。</p>
<p><strong>TomcatWebAppClassLoader</strong> 加载类的时候，按如下顺序加载类，加载到则结束：</p>
<ul>
<li>pandora.exportedClass</li>
<li>pandora.exportedBundleClass</li>
<li>${webroot}/WEB-INFO/lib/</li>
</ul>
<p>整体逻辑图如下：</p>
<p><img src="http://tempwork.qiniudn.com/taobao-tomcat-pandroa.jpg" alt="taobao-tomcat"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2016/01/30/taobao-tomcat类加载机制/" data-id="cijzwapqq000go8bu8tj95m6p" class="article-share-link" data-share="baidu" data-title="taobao-tomcat类加载机制">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-开源tomcat类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/29/开源tomcat类加载机制/" class="article-date">
  <time datetime="2016-01-29T08:56:44.000Z" itemprop="datePublished">1月 29 2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/29/开源tomcat类加载机制/">开源tomcat类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经典阅读tomcat源码的方式是从Bootstrap类开始。</p>
<p><img src="http://tempwork.qiniudn.com/open-souce-tomcat1.jpg" alt="initClassLoaders"></p>
<p>PS：tomcat7 和tomcat8有一个<strong>StandardClossLoader</strong>的区别，如下：</p>
<p><img src="http://tempwork.qiniudn.com/open-souce-tomcat2.jpg" alt="StandardClossLoader"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2016/01/29/开源tomcat类加载机制/" data-id="cijzwapqn000ao8bueo5ywcaz" class="article-share-link" data-share="baidu" data-title="开源tomcat类加载机制">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ASM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/28/ASM/" class="article-date">
  <time datetime="2016-01-28T07:22:34.000Z" itemprop="datePublished">1月 28 2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/ASM/">ASM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ASM是个2002年就开始的项目，真是古老至极。许多流行且包含了动态代理功能的框架应该直接或者间接使用了asm（cglib是基于asm做的二次开发）。</p>
<p>在最近的项目中使用到了asm，所以做了一些小记，内容有翻译，有摘录，有总结。</p>
<h4 id="ASM_模型">ASM 模型</h4><p>ASM提供了两套API：</p>
<ul>
<li><p>core API : 提供 event-based 字节码控制。</p>
<p>  asm通过JVMS定义的字节码结构把字节码中的如field，method 声明，指令等变成event，然后操纵event以达成修改字节码的目的。</p>
<p>  相关主要类：ClassVisitor, MethodVisitor (4.0之前还有基于这两个类的如 ClassAdapter 类等)</p>
</li>
<li><p>tree API : 提供 tree-based 字节码控制</p>
<p>  基于event-based的模型，继续抽象了下，用一棵树的形式展现字节码。</p>
<p>  相关主要类：ClassNode, MethodNode</p>
</li>
</ul>
<p>在<a href="file:///Users/tingjieding/Dropbox/See%20my%20life%20here/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/asm4-guide.pdf" target="_blank" rel="external">此文</a>中就拿了SAX 和 DOM 来描述解析xml的比较 来 类比 core API 和 tree API 的比较：</p>
<ul>
<li><p>core API 比 tree API 占用更少的系统资源。从内存的角度看：tree API 由于要把字节码抽象成tree，在内存中会占用跟多的空间</p>
</li>
<li><p>core API 比 tree API 更难用，每次只能操作一个指令，需要非常了解字节码相关规范，写起来要小心翼翼。</p>
</li>
</ul>
<h4 id="ASM_架构">ASM 架构</h4><p>经典图如下：<br><img src="http://img.blog.csdn.net/20140809214609558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHlzbWlyYWNsZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="经典图"></p>
<p>使用了经典的 producer-consumer 模型，中间的白框都是filter。</p>
<pre><code><span class="comment">producer</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">filters</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">consumer:</span>
</code></pre><p>对于Class：</p>
<pre><code>ClassReader 是 producer，<span class="built_in">filter</span> 都是 ClassVisitor 的实现类，ClassWriter 作为 consumer。
</code></pre><p>对于Method：</p>
<pre><code>ClassReader 是 producer, <span class="built_in">filter</span> 是 MethodVistor 的实现类, MethodWriter 作为consumer。
</code></pre><p>对于Field：</p>
<pre><code>ClassReader 是 producer， <span class="built_in">filter</span> 是 FieldVistor 的实现类， FieldWriter 作为consumer。
</code></pre><h4 id="ASM_实例">ASM 实例</h4><p>添加System.out.println(“here I am”); 代码到方法中:</p>
<ul>
<li><p>core api使用方法如下：</p>
<pre><code>ClassReader cr <span class="subst">=</span> <span class="literal">new</span> ClassReader(<span class="built_in">bytes</span>);
ClassWriter cw <span class="subst">=</span> <span class="literal">new</span> ClassWriter(cr, COMPUTE_FRAMES <span class="subst">|</span> COMPUTE_MAXS); <span class="comment">//cr只是定义来源reader，无用。</span>
ClassVisitor cv <span class="subst">=</span> <span class="literal">new</span> ClassVisitor(Opcodes<span class="built_in">.</span>ASM5, cw){
    <span class="attribute">...</span><span class="built_in">.
</span>}
cr<span class="built_in">.</span>accept(cv, ClassReader<span class="built_in">.</span>EXPAND_FRAMES);                
<span class="keyword">return</span> cw<span class="built_in">.</span>toByteArray();

<span class="comment">//cr--&gt;cv--&gt;cw</span>
</code></pre></li>
<li><p>tree api使用方法如下：</p>
<pre><code><span class="type">ClassReader</span> cr = new <span class="type">ClassReader</span>(bytecode);
<span class="type">ClassNode</span> cn = new <span class="type">ClassNode</span>();
cr.accept(cn, <span class="type">ClassReader</span>.<span class="type">SKIP_DEBUG</span>);

<span class="type">List</span> methods = cn.methods;
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; methods.size(); ++i) {
    <span class="type">MethodNode</span> <span class="keyword">method</span> = (<span class="type">MethodNode</span>) methods.get(i);
    <span class="keyword">if</span> (<span class="keyword">method</span>.instructions.size() &gt; <span class="number">0</span>) {                   instructions.insert(new <span class="type">FieldInsnNode</span>(<span class="type">Opcodes</span>.<span class="type">GETSTATIC</span>, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>)); 
        instructions.insert(new <span class="type">LdcInsnNode</span>(<span class="string">"hi, here I am!"</span>));
        instructions.insert(new <span class="type">MethodInsnNode</span>(<span class="type">Opcodes</span>.<span class="type">INVOKEVIRTUAL</span>, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="literal">false</span>))
    }
}
<span class="type">ClassWriter</span> cw = new <span class="type">ClassWriter</span>(<span class="type">COMPUTE_FRAMES</span> | <span class="type">COMPUTE_MAXS</span>);
cn.accept(c);
<span class="keyword">return</span> cw.toByteArray();

//cr--&gt;cn--&gt;cw
</code></pre></li>
</ul>
<p>PS：推荐在IDE上面安装<a href="https://plugins.jetbrains.com/plugin/5918?pr=idea" target="_blank" rel="external">ASM字节码工具</a>，在一个正常类里面写完代码以后，用工具一转，可以参考转出的字节码，开始写asm相关代码了。</p>
<h3 id="ASM其他">ASM其他</h3><h4 id="ASM_core_api">ASM core api</h4><ul>
<li><p>TraceClassVisitor:</p>
<p>  通过 <strong>PrintWriter</strong> 实例打印可读的字节码信息。</p>
</li>
<li><p>CheckClassAdapter</p>
<p>  在被JVM拒绝之前检测修改后的字节码是否合法。</p>
</li>
<li><p>AnalyzerAdapter</p>
<p>  可以自动计算stack的深度，感觉没太大作用，在ClassWriter的option里面有两个选项：<strong>COMPUTE_FRAMES, COMPUTE_MAXS</strong></p>
</li>
<li><p>LocalVariablesSorter</p>
<p>  有newLocal方法可以添加local variable，自动维护local variable数量变化，引起的local variable对应的index变化的问题。</p>
</li>
<li><p>AdviceAdapter</p>
<p>  有onMethodEnter()和onMethodExit()方法，可以在方法最开始和RETURN 或者 ATHROW指令之前插入指令。</p>
</li>
</ul>
<p>Metadata 相关 vistor：SignatureVisitor， AnnotationVisitor。这两个还没有用过，暂做记录。</p>
<h4 id="ASM_tree_api">ASM tree api</h4><p>实际使用的时候，碰到了问题，没有细看，暂做记录。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2016/01/28/ASM/" data-id="cijzwapr3000ro8buo0fr6tzy" class="article-share-link" data-share="baidu" data-title="ASM">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Zero-Copy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/19/Zero-Copy/" class="article-date">
  <time datetime="2016-01-19T03:51:02.000Z" itemprop="datePublished">1月 19 2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/Zero-Copy/">Zero Copy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>xflush，metaq都适用了zero copy技术来提高性能，多次看到这个词，却一直没有理解透彻，于是找了一些资料了解。以下此技术点知识的翻译及汇总。</p>
<p>翻译自<a href="http://www.linuxjournal.com/article/6345" target="_blank" rel="external">这里</a></p>
<p>到目前为止几乎所有的人都听说过linux下的所谓的zero-copy，但是我还是经常碰到不能完全理解这个内容的人。 基于此，我打算写一些文章深挖，剖析一下这个有用的功能。在这个文章里面，我们从user-mode（用户模式）应用这个角度来看下zero copy， 所以更详尽的kernel-level（内核）细节会被有意的忽略。</p>
<h4 id="What_is_Zero-Copy?">What is Zero-Copy?</h4><p>为了更好的理解一个问题的解决方案，我们首先需要的是理解问题本身。让我们了解下网络服务器进程（？network server dæmon ）为client端提供数据存储在文件中的服务的简单过程中包含了什么。一下是实例代码：</p>
<pre><code><span class="keyword">read</span>(<span class="keyword">file</span>, tmp_buf, <span class="built_in">len</span>);

<span class="keyword">write</span>(socket, tmp_buf, <span class="built_in">len</span>);
</code></pre><p>看起来非常简单；你可能会想里面最多也就两个系统调用（system calls）。事实上，实时也就是如此。在这两次调用之后，数据（data）已经被复制了最少四次，同时执行了相同次数的 user/kernel mode上下文切换 。（事实上这个过程比这个描述的更复杂）。为了更深入的理解这个过程，请看图1。上半部展示了user/kernel mode上下文切换，并且下半部展示了复制操作。</p>
<p><img src="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f1.jpg" alt="Copying in Two Sample System Calls"></p>
<ul>
<li><p>第一步：读系统调用（read system call）引起了从user mode to kernel mode 的上下文切换。第一次的copy被DMA engine执行，它从磁盘中读取了文件的内容然后存储到kernel address space buffer 里面。</p>
</li>
<li><p>第二步：第二次的copy是数据从kernel buffer 复制到 user buffer，然后读系统调用（read system call）返回。这个 返回 引起了从 kernel mode 变回 user mode 的上下文切换。现在数据被存在了user address space buffer了。</p>
</li>
<li><p>第三步：写系统调用（write system call）引起了从user mode to kernel mode。第三次copy是为了把再次把数据放入到kernel address space buffer。这次数据被放在了不同的buffer，是跟sockets相关的buffer。</p>
</li>
<li><p>第四步：写系统调用（write system call）返回，创建了我们的第四次的上下文切换。异步且于之前不依赖（Independently and asynchronously）的情况下，第四次是在DMA engine 从kernel buffer 复制 到 protocol engine的时候发生的。你可能问自己，“什么是 Independently and asynchronously？ 数据难道不是在调用返回之前就完成数据传输的么？” 事实上，调用返回 步保证 输入传输完成；它甚至步保证数据开始传输。 它只是意味着网卡驱动在其处理队列中有清空的描述符（？free descriptors）并且接收了我们需要传输的数据。这个时候在网卡的处理队列中可能还有很多的数据包在我们的数据之前。除非驱动／硬件实现了优先级环活着队列，不然数据在处理队列中都是按照先进先出的方式传输的。（带分叉的DMA 复制 表示了最后的复制能够被延迟）。</p>
</li>
</ul>
<p>正如你所看到的， 以上过程有很多的数据复制是不必要的。其中一部分复制是可以消除来减少资源浪费以提高性能的。 作为一个驱动开发者， 我在一些有非常先进功能的硬件上面工作过。有些硬件能够绕过主存直接传送数据到另外一个设备。这个功能能够减少系统内存中的数据冗余，非常值得拥有，但是不是所有的硬件都是支持的。可能还会存在额外的数据问题会引入一定的复杂性：来源于disk的数据需要repackage才能发送给网卡。 为了减少资源浪费， 我们可以从减少kernel buffers和 user buffers之间的数据复制。</p>
<p>减少一次复制的一种方法是跳过调用 read 而用 调用 mmap 来替代。举例来说：</p>
<pre><code>tmp_buf = mmp(<span class="keyword">file</span>, <span class="built_in">len</span>);
<span class="keyword">write</span>(socket, tmp_buf, <span class="built_in">len</span>);
</code></pre><p>为了更好的了解这个过程，请看下图 2. Context switches（上下文切换）仍然一样。<br><img src="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f2.jpg" alt="Calling mmap"></p>
<ul>
<li><p>第一步：mmap 系统调用通过DMA engine复制到kernel buffer。这个buffer之后会被user process（用户京城）共享使用，而不需要在kernel memory space 和 user memory sapce之间执行数据的复制。</p>
</li>
<li><p>第二步：写系统调用让kernal 把之前的 kernel buffer中的数据传输到 socket相关的kernel buffer。</p>
</li>
<li><p>第三步：第三次数据复制发生在 DMA engine 传输数据从 kernel socket buffers 到protocal engine。</p>
</li>
</ul>
<p>通过使用mmap来替代read，我们已经减少了一半的kernel不得步复制的次数。在大量数据需要传输的时候，这种方式带来了很好的结果。然而，这种提升不是没有代价的；这种使用mmap＋write方法的方式会存在隐藏的陷阱。其中一种情况是党你正在使用mmap（memory map）读取文件的时候并且已经调用了write操作 的时候，另外一个线程删减了文件的部分内容。你的write system call 就会被bus error（signal SIGBUS）打断，因为你执行了一个次有问题的内存访问。这个signal的默认行为就是杀死对应的进程和dump core－－但对网络服务器无法记全所有希望了解的操作。有两种方式能够解决这个问题。</p>
<ul>
<li><p>第一种解决方案是为 SIGBUS signal 添加singal handler，然后handler只要简单的return逻辑就可以了。通过这种方式，write system call 会返回在它被中断前要写的字节流并且errno会被设置成success。这种方式在我看来是一种不好的解决方案，只是一种处理了表层症状而不是问题的根本的方式。因为SIGBUS signals 有时候说明了进程出现了非常严重的问题，但现在却被屏蔽了，所以不推荐使用这种方案。</p>
</li>
<li><p>第二种解决方案使用了 kernel 的file leasing[文件租约]（在Microsoft Windows里面叫做“opportunistic locking”）。我认为这是一种解决这个问题的正确方法。通过在文件描述符(file descriptor)续约(leasing)，你可以在kernel中获得某个具体文件的租约(lease)。紧接着你可以在kernel中请求一次读／写租约(lease)。当另一个进程尝试着删减(修改)你正在传输的文件内容的时候，kernel会发送给你一个实时的signal，RT_SIGNAL_LEASE signal。它告诉你kernel正在打断你在某个文件上面的读／写租约。你的write system call会在你的程序访问非法地址和北SIGBUS signal杀掉之前就被中断。write system call 返回的数据是中断之间将要卸乳的字节流数据，并且errno 会被设置成 success。一下是从kernel获得租约的事例代码：</p>
<pre><code><span class="keyword">if</span>(fcntl(fd, F_SETSIG, RT_SIGNAL_LEASE) == -<span class="number">1</span>) {
    perror(<span class="string">"kernel lease set signal"</span>);
    <span class="built_in">return</span> -<span class="number">1</span>;
}
/* l_<span class="built_in">type</span> can be F_RDLCK F_WRLCK */
<span class="keyword">if</span>(fcntl(fd, F_SETLEASE, l_<span class="built_in">type</span>)){
    perror(<span class="string">"kernel lease set type"</span>);
    <span class="built_in">return</span> -<span class="number">1</span>;
}
</code></pre><p>你需要在 mmap 文件之前获得租约，然后在你完成逻辑之后解除租约。解除租约可以通过调用 fcntl F_SETLEASE with the lease type of F_UNLCK 来完成。</p>
</li>
</ul>
<p>在kerverl version 2.1, the sendfile system call 被添加来简化网络内机器之间或一台机器本地文件之间的数据传输。 sendfile 不但能减少数据的复制，还能减少context switches(kernel， user)，是按照如下方式使用的：</p>
<pre><code>sendfile(<span class="keyword">socket</span>, <span class="keyword">file</span>, len);
</code></pre><p>为了更好的理解这个过程，请看图3.<br><img src="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f4.jpg" alt="图3"></p>
<ul>
<li><p>第一步：sendfile system call 把文件的数据通过DMA engine 复制到kernel buffer里面。然后数据通过kernel复制到sockets相关的kernel buffer里面。</p>
</li>
<li><p>第二步：第三次的复制是当DMA engine 从kernel socket buffers中数据传送数据到protocal engine中。</p>
</li>
</ul>
<p>你可能会想当另外一个线程删减这个我们正在使用sendfile system call 来传输的文件的时候会发生什么。如果我们没有注册任何signal handlers（信号量处理器），sendfile call 会返回被中断之前将要传输的字节流，并且errno会被设置为sucess状态。</p>
<p>如果我们在调用sendfile之前通过kernel获得获得文件的租约，那么之后的行为和返回状态就和之前描述的一样。我们也会在sendfile call 返回之前得到RT_SIGNAL_LEASE信号量。</p>
<p>到现在位置，我们已经能够减少若干次kernel发生的数据复制了，但是我们仍然留下了一次复制。那么是否那次复制也能避免？当然可以，只要通过一些硬件的帮助。为了消除所有通过kernel完成的数据复制，我们需要网卡支持gather(聚合) operations。简单理解就是等在等待被传输的数据不需要在连续的内存中；他们能够被存储在不同的内存位置。在内部版本2.4，socket buffer discriptor为了适应这些需求而做了修改－－这就是Linux的zero copy。这个方法不但减少多次的context switches，而且它减少processors(处理器)完成的多次数据复制。对于user-level的应用什么都不需要改变，代码仍然如下：</p>
<pre><code>sendfile(<span class="keyword">socket</span>, <span class="keyword">file</span>, len);
</code></pre><p>为了能够更深入的理解这个过程，请看图4.<br><img src="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f4.jpg" alt="图4"></p>
<ul>
<li><p>第一步：the sendfile system call 通过DMA engine复制数据内容至kernel buffer。</p>
</li>
<li><p>第二步：没有数据被复制到socket buffer。只有包含数据的 whereabouts（内存地址信息？）和长度信息的descriptors(描述符号)才被添加到socket buffer。The DMA engine 直接把数据从kernel buffer 传递到 protocol engine，所以消除了剩余最后的数据复制。</p>
</li>
</ul>
<p>因为数据实际上仍然从disk复制到了memory并且之后从memory到了wire，有人可能会说这个不是真正的 zero copy。 之前所描述的是 操作系统角度 的zero copy，因为数据没有在kernel buffers之间被复制。当使用zero copy的时候，能得到除了避免数据复制之外的性能提升，例如更少的context switches，更少的CPU data cache pollution（cpu 数据缓存污染，不需要修改cpu的缓存内容？）和 no CPU checksum calculations（这个是什么？）</p>
<h4 id="How_to_use_Zero-Copy?">How to use Zero-Copy?</h4><p>现在我们知道了什么是zero copy，让我们实践下理论并且写一些代码吧。</p>
<p>C的代码参考<a href="http://www.linuxjournal.com/article/6345" target="_blank" rel="external">这里</a></p>
<p>以下为JAVA中如何完成zero copy，只要使用api：</p>
<pre><code>java.nio.channel.FileChannel的transferTo(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel <span class="keyword">target</span>) <span class="keyword">throws</span> IOException;
</code></pre><p>来自<a href="">参考</a>的性能数据：</p>
<table>
<thead>
<tr>
<th>File size</th>
<th>Normal file transfer (ms)</th>
<th>transferTo (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>7MB</td>
<td>156</td>
<td>45</td>
</tr>
<tr>
<td>21MB</td>
<td>337</td>
<td>128</td>
</tr>
<tr>
<td>63MB</td>
<td>843</td>
<td>387</td>
</tr>
<tr>
<td>98MB</td>
<td>1320</td>
<td>617</td>
</tr>
<tr>
<td>200MB</td>
<td>2124</td>
<td>1150</td>
</tr>
<tr>
<td>350MB</td>
<td>3631</td>
<td>1762</td>
</tr>
<tr>
<td>700MB</td>
<td>13498</td>
<td>4422</td>
</tr>
<tr>
<td>1GB</td>
<td>18399</td>
<td>8537</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2016/01/19/Zero-Copy/" data-id="cijzwapqu000jo8buwfkug9o1" class="article-share-link" data-share="baidu" data-title="Zero Copy">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-认识java-agent" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/26/认识java-agent/" class="article-date">
  <time datetime="2015-12-26T14:25:02.000Z" itemprop="datePublished">12月 26 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/26/认识java-agent/">认识java agent</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="java_agent">java agent</h4><h6 id="agent">agent</h6><p>java agent是在JDK1.5之后引入的，是main方法之前的拦截器；其作用是在main之前之前执行agent中的逻辑。</p>
<p>假设 A 是主要业务逻辑应用所在进程； B 是要拦截在A的main方法之前的 agent。</p>
<p>那么agent有两种启动方式：</p>
<ul>
<li><p>（1）B在A之前启动：通过 启动A时添加vm参数 -javaagent:xxxx.jar</p>
<p>  a. xxxx.jar包含了自己实现的agent类，实现规范中一种形式如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentOps, Instrumentation inst)</span></span>{  
    <span class="comment">//TODO </span>
}
</code></pre><p>  b. xxxx.jar包含的资源配置文件Manifest中需要指明premain所在的类：</p>
<pre><code>Premain-Class: com<span class="class">.mypackage</span><span class="class">.MyAgent</span>
</code></pre></li>
</ul>
<ul>
<li><p>（2）B在A之后启动：通过 VirtualMachine 的 attach 和 loadAgent 方法实现。</p>
<p>  VirtualMachine类所在包为：com.sun.tools.attach；相关代码：</p>
<pre><code><span class="keyword">try</span>{
    <span class="built_in">String</span> pid = fetchPidId(); <span class="comment">//获取到java 的 pid（各种方式）</span>
    <span class="keyword">if</span>( pid != <span class="keyword">null</span> ){
        vm = VirtualMachine.attach( pid );    <span class="comment">// 获取attach到的vm对象实例                                 </span>
        vm.loadAgent(agentJarFilePath, args); <span class="comment">// 加载agent</span>
    }
}<span class="keyword">finally</span> {
    vm.detach();
}
</code></pre><p>  a. agentJarFilePath包含了自己实现的agent类，实现规范中一种形式如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span> </span>{
    <span class="comment">//TODO</span>
}
</code></pre><p>  b. agentJarFilePath包含了资源配置文件Manifest中需要指明agentmain所在的类：</p>
<pre><code><span class="attribute">Agent-Class</span>: <span class="string">war.Hatch</span>
</code></pre></li>
</ul>
<p><strong><em>tips</em></strong>：<br>资源描述文件Manifest里面agent相关的额外配置项如下：</p>
<ul>
<li><p>Can-Redefine-Classes</p>
<p>  如果此值为true，可以修改已经加载的class的字节码。</p>
</li>
<li><p>Can-Retransform-Classes  </p>
<p>  如果此值为true，表示支持重复修改class的字节码。这个和redefine的区别是，transform只是一个filter，没有修改本源字节码。</p>
</li>
</ul>
<h6 id="instrument">instrument</h6><p>在<strong>agent</strong>介绍中，我们可以看到instrument的身影，用来增强字节码。</p>
<p>instrument中可以：</p>
<pre><code><span class="number">1.</span> 在 A 所在的JVM进程的BootstrapClassLoader 或者 SystemClassLoader（AppClassLoader）中加载额外的jar包。
<span class="number">2.</span> 可以获得 A 中已经加载的所有的<span class="class"><span class="keyword">class</span>类。</span>
<span class="number">3.</span> 可以添加 ClassFileTransformer 类来进行<span class="class"><span class="keyword">class</span>文件（字节码）的修改。</span>
    instrument.add
</code></pre><p>更多请参考API。<a href="http://www.chinaxing.org/articles/Java/2014/09/25/2014-09-24-instrumentation.html" target="_blank" rel="external">这里</a>有一篇比较好的理解，强烈推荐。</p>
<h6 id="实践经验">实践经验</h6><ul>
<li><p>因为com.sun.tools.attach.VirtualMachine在tools.jar中，所以在（2）情况下要调用其attach和loadAgent的时候，需要在classpath中添加tools.jar。形如：</p>
<pre><code>java -<span class="keyword">classpath</span> {JAVA_HOME}<span class="regexp">/lib/</span>tools.jar:myTransport.jar Transport
</code></pre><p>  Transport 中的main方法包含了（2）中的示例代码。</p>
</li>
<li><p>加入是用maven打包的推荐使用 maven-assembly-plugin，用其<manifestentries>来管理资源管理文件配置项，示例配置如下：</manifestentries></p>
<pre><code><span class="tag">&lt;<span class="title">manifestEntries</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Premain-Class</span>&gt;</span>agent<span class="tag">&lt;/<span class="title">Premain-Class</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Agent-Class</span>&gt;</span>agent<span class="tag">&lt;/<span class="title">Agent-Class</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Can-Redine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="title">Can-Redine-Classes</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="title">Can-Retransform-Classes</span>&gt;</span>
<span class="tag">&lt;/<span class="title">manifestEntries</span>&gt;</span>
</code></pre></li>
<li><p>获取PID的示例命令：</p>
<pre><code>ps ax | grep <span class="string">'java'</span> | cut <span class="operator">-d</span> <span class="string">" "</span> <span class="operator">-f</span>2
</code></pre></li>
</ul>
<h6 id="agent技术已知商业价值">agent技术已知商业价值</h6><ul>
<li>性能剖析：Btrace</li>
<li>错误诊断：Btrace， Greys</li>
<li>AOP切面技术：Spring</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2015/12/26/认识java-agent/" data-id="cijzwapqf0002o8bujr0e1hqv" class="article-share-link" data-share="baidu" data-title="认识java agent">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVMS7笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/20/JVMS7笔记/" class="article-date">
  <time datetime="2015-12-20T08:07:58.000Z" itemprop="datePublished">12月 20 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/20/JVMS7笔记/">JVMS7笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Structure of JVM</p>
<hr>
<p>DataTypes:</p>
<ul>
<li><p>primitive types </p>
<ul>
<li>Integral Types : int, long, short, char。</li>
<li>Boolean Type : 计算的时候使用int。</li>
<li>Floating-Point Types : float, double。</li>
<li>the returnAddress Type : 开发不能直接使用。</li>
</ul>
</li>
<li><p>reference types</p>
<ul>
<li>足够长来存储指针，长度一般与机器位数相同。</li>
</ul>
</li>
</ul>
<hr>
<p>Runtime Data Areas:</p>
<ul>
<li><p>The <strong>pc</strong> Register</p>
<p>  正常指向指令的地址。</p>
<ul>
<li>执行native方法的时候，pc是不存在值的。</li>
</ul>
</li>
<li><p>Java Virtual Machine Stacks</p>
<p>  每个线程都有自己的stack，stack存储了frames。</p>
<ul>
<li><p>frame</p>
<p>  A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p>
<p>  A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the Java virtual machine stack (§2.5.2) of the thread creating the frame. Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the runtime constant pool (§2.5.5) of the class of the current method.</p>
<ul>
<li><p>Local Variables</p>
<p>  一个local variable 占用一个word size；long，double占用两个word size，所以是两个local variable。 0 local variable 为被调用的method所在的object的reference（即this），方法的参数从1 local variable 开始连续 存储。</p>
<pre><code>JVM 设计的word size 不同于 word（<span class="number">8</span> bits） <span class="keyword">in</span> computer science：

The basic <span class="keyword">unit</span> <span class="keyword">of</span> size <span class="keyword">for</span> data values <span class="keyword">in</span> the Java <span class="keyword">virtual</span> machine <span class="keyword">is</span> the word--a fixed size chosen <span class="keyword">by</span> the designer <span class="keyword">of</span> <span class="keyword">each</span> Java <span class="keyword">virtual</span> machine <span class="keyword">implementation</span>. The word size must be large enough <span class="keyword">to</span> hold a value <span class="keyword">of</span> <span class="keyword">type</span> byte, short, int, char, float, returnAddress, <span class="keyword">or</span> <span class="keyword">reference</span>. Two words must be large enough <span class="keyword">to</span> hold a value <span class="keyword">of</span> <span class="keyword">type</span> long <span class="keyword">or</span> double. An <span class="keyword">implementation</span> designer must therefore choose a word size that <span class="keyword">is</span> at least <span class="number">32</span> bits, but otherwise can pick whatever word size will <span class="keyword">yield</span> the most efficient <span class="keyword">implementation</span>. The word size <span class="keyword">is</span> often chosen <span class="keyword">to</span> be the size <span class="keyword">of</span> a native pointer <span class="keyword">on</span> the host <span class="keyword">platform</span>.
</code></pre></li>
<li><p>Operand Stacks</p>
<pre><code>Each frame (§<span class="number">2.6</span>) <span class="keyword">contains</span> a <span class="keyword">last</span>-<span class="keyword">in</span>-<span class="keyword">first</span>-out (LIFO) stack known <span class="keyword">as</span> <span class="keyword">its</span> operand stack.
</code></pre></li>
<li><p>Dynamic Linking</p>
<pre><code><span class="type">The</span> class file code <span class="keyword">for</span> a <span class="keyword">method</span> refers to methods to be invoked <span class="keyword">and</span> variables to be accessed via symbolic references.
</code></pre></li>
<li><p>Special Methods</p>
<pre><code>每一个construction都是&lt;init&gt;方法；每一个默认的Void 且没有参数的contruction是&lt;clinit&gt;方法。
they are never invoked directly <span class="keyword">from</span> any Java <span class="keyword">virtual</span> machine instruction, but are invoked only indirectly <span class="keyword">as</span> part <span class="keyword">of</span> the <span class="keyword">class</span> initialization process.
signature polymorphic（MethodHandler）这个也是JDK7加入的，为了实现JSR292，为在JVM上实现动态语言提供更多的支持。MethodHandle是JSR292的重要组成部分之一。invokevirtual 指令会对siglenature polymorphic <span class="function"><span class="keyword">method</span>（<span class="title">MethodHandler</span>以及子类）多特殊处理。</span>
</code></pre></li>
<li><p>Exception</p>
<pre><code>同步异常（synchronous exception）抛出的方式：
<span class="bullet">1. </span>athrow 指令的调用
<span class="bullet">2. </span>JVM相关的Error，类loading，liking阶段相关的Exception，OutOfMemory，StackOverflow，RuntimeException的继承类等。
异步异常（asynchronous exception）抛出的方式：
<span class="bullet">1. </span>Thread或者ThreadGroup的stop方法被触发。
<span class="bullet">2. </span>JVM内部的错误
<span class="code">    JVM允许异步的异常抛出存在一定的延迟，在最适合的时候记性处理－－在这段延迟中，可以让JVM重排指令来优化代码和计算。（比较简单的实现方式是：在每条[control transfer instruction]执行的时候才去poll异步的异常。正是因为有这个保证，所以control transfer instruction之间的指令能够被JVM优化）</span>
</code></pre><p>  在class文件中，excpetion handlers都存在table里面。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Heap</p>
<p>  Heap的管理是通过automacic storage management system，JVMS的实现可以实现自己heap管理机制。</p>
</li>
<li><p>Method Area</p>
<p>  It stores per-class structures such as the runtime constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization</p>
<ul>
<li><p>一般JVMS简单的实现是不会选择去处理Method Area的，但是这个版本的JVMS没有强制要求这么做。</p>
</li>
<li><p>Runtime Constant Pool</p>
<pre><code>A runtime <span class="type">constant</span> pool <span class="keyword">is</span> a per-<span class="type">class</span> <span class="keyword">or</span> per-interface runtime representation <span class="keyword">of</span> <span class="keyword">the</span> constant_pool table <span class="keyword">in</span> a <span class="type">class</span> <span class="type">file</span> (§<span class="number">4.4</span>). It <span class="keyword">contains</span> several kinds <span class="keyword">of</span> constants, ranging <span class="keyword">from</span> numeric literals known <span class="keyword">at</span> compile-<span class="property">time</span> <span class="keyword">to</span> method <span class="keyword">and</span> field references <span class="keyword">that</span> must be resolved <span class="keyword">at</span> runtime. The runtime <span class="type">constant</span> pool serves a function similar <span class="keyword">to</span> <span class="keyword">that</span> <span class="keyword">of</span> a symbol table <span class="keyword">for</span> a conventional programming language, although <span class="keyword">it</span> <span class="keyword">contains</span> a wider range <span class="keyword">of</span> data than a typical symbol table.
</code></pre></li>
</ul>
</li>
</ul>
<hr>
<p>Instruction Summary:</p>
<p>字节码指令流一般是按照字节排列的，只有lookupswitch &amp; tableswitch 比较特别。</p>
<ul>
<li><p>instructions with type info:</p>
<p>  指令集里面有部分是可以之间看出类型，比如iadd表示可以计算int类型的数据，fadd表示计算float类型的的数据等。但是要每个指令都支持所有的类型，是不现实的，因为一个byte只有8位。所以最后char，boolean，short等的add指令都会被转换成int的计算（使用iadd）。</p>
</li>
<li><p>instructions regardless of type info:</p>
<p>  指令集里面的类似push，pop，swap等是不带type信息的，只关心使用到的category of computational types。</p>
<ul>
<li><p>Category 1: </p>
<p>  boolean, byte, char, short, int 的计算类型是 int； float计算类型位float；reference为reference；returnAddress为returnAddress；</p>
</li>
<li><p>Category 2: </p>
<p>  long的计算类型为long， double计算类型为double，</p>
</li>
</ul>
</li>
<li><p>指令概览</p>
<ul>
<li><p>支持的类型widening指令（ i2l, i2f, i2d, l2f, l2d, and f2d）：</p>
<ul>
<li>int to long, float, or double</li>
<li>long to float or double</li>
<li>float to double</li>
</ul>
</li>
<li><p>支持的narrowing指令（i2b, i2c, i2s, l2i, f2i, f2l, d2i, d2l, and d2f）：</p>
<ul>
<li>int to byte, short, or char</li>
<li>long to int</li>
<li>float to int or long</li>
<li>double to int, long, or float</li>
</ul>
<p>类型转换过程中，会存在一定的信息丢失情况，具体需要具体翻看了解。</p>
</li>
<li><p>支持的 control transfer instruction 分为以下几类：</p>
<ul>
<li><p>conditional branch: </p>
<p>  ifeq, ifne, iflt, ifle, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmplt, if_icmple, if_icmpgt if_icmpge, if_acmpeq, if_acmpne</p>
</li>
<li><p>compound conditional brach: </p>
<p>  tableswitch, lookupswitch</p>
</li>
<li><p>unconditional brach: </p>
<p>  goto, goto_w, jsr, jsr_w, ret</p>
</li>
</ul>
</li>
<li><p>5种方法调用指令：</p>
<ul>
<li>invokevirtual: 调用类实例的方法</li>
<li>invokeinterface: ???</li>
<li>invokespecial: init, private, super class的方法</li>
<li>invokestatic: 调用类的方法</li>
<li>invokedynamic: 关联到MethodHandle，看了相关的资料，暂时还没有领会其用途（？？？）</li>
</ul>
</li>
<li><p>同步, 分为两类：</p>
<ul>
<li>method synchronization</li>
<li><p>block synchronization</p>
<p>moniterenter，moniterexit 这两个指令配合完成同步。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h6 id="Compiling_for_JVM">Compiling for JVM</h6><p>tableswitch是switch 连续的int 和 lookupswitch是switch离散的int。排序过的switch key 效率更高；tableswitch效率比lookupswitch高。</p>
<p>try-catch statements：</p>
<pre><code>As a subtle point, note <span class="keyword">that</span> <span class="keyword">the</span> range <span class="keyword">of</span> a catch clause <span class="keyword">is</span> inclusive <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="string">"from"</span> <span class="keyword">end</span> <span class="keyword">and</span> exclusive <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="string">"to"</span> <span class="keyword">end</span>.
</code></pre><p>A Java virtual machine implementation verifies that each class file satisfies the necessary constraints at linking time</p>
<p>String.intern() 会找到runtime constant pool中相同字符串的引用地址</p>
<p><strong>skip Class file format &amp; Verification of Class Files</strong></p>
<hr>
<h6 id="Loading,_Linking,_and_Initializing">Loading, Linking, and Initializing</h6><p>VM Start-up</p>
<p>调用bootstrap classloader 加载 初始化类，然后加载main方法；一般jvm的实现都有 命令行参数 或者 提供 初始化参数的方式。</p>
<p>Creation and Loading</p>
<p>C代表一个interface or class;</p>
<p>N代表internal name of C in JVM implementation;</p>
<p>D触发了C的创建：D的runtime contant pool有C的引用 或者 D通过反射创建C</p>
<p>A class loader L may create C by defining it directly or by delegating to another class loader. <strong>If L creates C directly, we say that L defines C or, equivalently, that L is the defining loader of C.</strong></p>
<p>When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class. <strong>If L creates C, either by defining it directly or by delegation, we say that L initiates loading of C or, equivalently, that L is an initiating loader of C.</strong></p>
<p>The Java virtual machine uses one of three procedures to create class or interface C denoted by N:</p>
<ul>
<li><p>If N denotes a nonarray class or an interface, one of the two following methods is used to load and thereby create C:</p>
<ul>
<li><p>If D was defined by the bootstrap class loader, then the bootstrap class loader initiates loading of C.</p>
</li>
<li><p>If D was defined by a user-defined class loader, then that same user-defined class loader initiates loading of C.</p>
</li>
</ul>
</li>
<li><p>Otherwise N denotes anarray class.An array class is created directly by the Java virtual machine, not by a class loader. However, the defining class loader of D is used in the process of creating array class C.</p>
</li>
</ul>
<p>在loading的阶段出现异常，抛出LinkageError的继承类。</p>
<p>&lt; $$$ N, L_d $$$ &gt; : N denotes the name of the class or interface and $$$ L_d $$$ denotes the defining loader of the class or interface.</p>
<p>$$$ N^{L_i} $$$ : N denotes the name of the class or interface and $$$ L_i $$$ denotes an initiating loader of the class or interface.</p>
<hr>
<p>Linking:</p>
<p>如果JVM在Verification or Resolution class C的时候抛出了ClassNotFoundException的时候，会被包装成NoClassDefFoundError.（Loading of superclass 是 Rsolution逻辑的一部分）</p>
<ul>
<li>Verification</li>
<li>Prepare</li>
<li>Resolusion: 这个可能在真正使用的时候（懒加载，invokedynamic指令）才会使用到；也有情况是直接使用。</li>
</ul>
<hr>
<p>Initializing:</p>
<p>ClassLoader.loadClass() 与 Class.forName()<br>ClassLoader.loadClass(String name, boolean resolve)，其中resolve默认为false，即只执行类装载的第一个阶段。</p>
<p>Class.forName(String name, boolean initialize, ClassLoader loader)， 其中initialize默认为true，即执行到类装载的第三个阶段。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2015/12/20/JVMS7笔记/" data-id="cijzwapqz000no8buqoi6qr3k" class="article-share-link" data-share="baidu" data-title="JVMS7笔记">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-理解CPU-steal-time" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/21/理解CPU-steal-time/" class="article-date">
  <time datetime="2015-11-21T06:37:04.000Z" itemprop="datePublished">11月 21 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/21/理解CPU-steal-time/">理解CPU steal time</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Netflix 很关注CPU的Steal Time。他们的策略是：如果是当前虚拟机的Steal Time 超过了你们设置的 阈值，他们会关闭这台虚拟机并且在另外一台物理机上面重启。</p>
<p>如果你想要部署虚拟环境（例如：Amazon EC2）， steal time就是你想要关注的性能指标之一。 如果这个指标的数值很高，那么说明机器状态非常糟糕。什么是steal time？什么会引发高steal time？多少才是警戒值（你需要做什么）？</p>
<h3 id="CPU_Steal_Time_的定义">CPU Steal Time 的定义</h3><p>From <a href="ibm.com">ibm</a>:</p>
<pre><code>Steal <span class="built_in">time</span> is <span class="operator">the</span> percentage <span class="operator">of</span> <span class="built_in">time</span> <span class="operator">a</span> virtual CPU waits <span class="keyword">for</span> <span class="operator">a</span> real CPU <span class="keyword">while</span> <span class="operator">the</span> hypervisor is servicing another virtual processor.
</code></pre><p>你的虚拟机（VM）会与虚拟环境的宿主机上的多个虚拟机实例共享物理资源。其中之一共享的就是CPU时间切片。如果你的VM的物理机虚拟比是1/4， 那么它的CPU使用率不会限制于25%的CPU时间切片－它能够使用超过它设置的虚拟比。（有别于内存的使用，内存大小是严格控制的）。</p>
<h3 id="哪里可以看到CPU_Steal_Time?">哪里可以看到CPU Steal Time?</h3><p>你可以使用Linux 的 TOP 命令来看到实时的一些性能指标。CPU相关的其中一行内容如下：<br><img src="https://dl.dropboxusercontent.com/u/468982/blog/steal/top_steal.png" alt="top"><br>两个你可能较为熟悉的是 %id(空闲 百分比) 和 %wa(I/O 等待 百分比)。 如果 %id 很低， 那么说明CPU的工作负载很大并且没有多少计算负载能力剩余。 如果 %wa 很高，则说明瓶 CPU 处于等待计算的状态，但是正在等待I/O活动的完成(类似 从数据库中获取存储在 磁盘上 的一行数据)。</p>
<p>%st（percent steal time） 是CPU展示的最后一个性能指标。</p>
<h3 id="CPU_Steal_Time_-_类比售票厅">CPU Steal Time - 类比售票厅</h3><p>假设你打算买了若干张最新的好莱坞大片的电影票，且有两条队伍等待买票和一个售票口：</p>
<p><img src="https://dl.dropboxusercontent.com/u/468982/blog/steal/movie_line.png" alt="Movie Theater"></p>
<p>如果我们把 CPU steal time 性能指标 类比成 售票的过程， 那么过程就是如下：</p>
<ul>
<li><p><strong>0% Steal Time</strong> - 现在是礼拜三下午场：售票口正在工作，先处理第一条队伍的电影观众，然后处理第二条，然后第一条，然后第二条，轮流进行。处理的很快，且没有人在等待。</p>
</li>
<li><p><strong>50% Steal Time</strong> - 现在是礼拜五晚上： 在队伍中的一个人有一半的时间需要等待另一个在售票口的人完成卖票，而不能立刻买到票。卖票的时间更长了。</p>
</li>
<li><p><strong>100% Steal Time</strong> - 现在是礼拜五晚上并且 现金出纳金 坏了：所有人都在等待。</p>
</li>
</ul>
<h3 id="为什么高_Steal_Time_会对web应用有更大的影响">为什么高 Steal Time 会对web应用有更大的影响</h3><p>如果有你在负载未满的物理机器上面运行一个长时间的计算任务，那么它可能会使用超过它额定的CPU切片 时间。过一段时间，可能其他的VMs可能也会需要超过它们额定量的CPU切片 时间，所以这个任务的执行会变慢。对于长时间计算任务而言之，这个情况可能并不是不能接受的：它可能是会晚点一完成或者也可能更快的完成（由于它能够使用更多的资源）。</p>
<p>然后，这种情况能够时代web应用停止响应。对于实时任务，类似快速响应许多的web请求，性能下降到1/4会对请求队列执行对应备选逻辑—中断请求。</p>
<h3 id="Steal_Time远高于0的原因">Steal Time远高于0的原因</h3><p>这里有两种可能性：</p>
<ol>
<li><p>你需要一个额定更多CPU资源的虚拟机（你的虚拟机<strong>是</strong>问题）</p>
</li>
<li><p>物理机已经超卖了并且多个虚拟机之间在激烈的竞争资源（你的虚拟机<strong>不是</strong>问题）</p>
</li>
</ol>
<p>提示：<strong>你不能通过看当前被影响的虚拟机实例的CPU性能指标来判断你所遇到的场景。（1 or 2）</strong> 当你有很多的虚拟宿主机上分别都部署了相同职责的服务程序（可能作为集群）时，就比较容易知道自己遇到的问题了。</p>
<p><img src="https://dl.dropboxusercontent.com/u/468982/blog/steal/steal_scenarios.png" alt="资源图片"></p>
<ul>
<li><p>是否 %st(CPU Steal Time Percentage) 在所有机器上面都上涨了？</p>
<p>  这个意味着你的虚拟机在使用更多的CPU资源。你需要为你的虚拟起增加更多的CPU资源的配额。</p>
</li>
<li><p>是否%st(CPU Steal Time Percentage) 只在一部分机器上面陡峭增长？</p>
<p>  这个意味着物理机器被超卖了。把你自己的虚拟机挪到另一个物理机器去吧。</p>
</li>
</ul>
<h3 id="所有，什么时候你应该担心？">所有，什么时候你应该担心？</h3><p>一般的参考标准-<strong>如果steal time 超过了10%并且持续了20分钟，那么虚拟机就可能性能下降了</strong></p>
<p>当这种情况发生：</p>
<ol>
<li><p>关闭虚拟机并且挪到另一台物理机器上面</p>
</li>
<li><p>如果steal time维持在很高的数值， 那么增加CPU资源配额。</p>
</li>
<li><p>如果steal time维持在很高的数值， 联系你的虚拟机提供商。你的虚拟机提供商有可能在超卖物理机。</p>
</li>
</ol>
<p><em>翻译自 <a href="http://blog.scoutapp.com/articles/2013/07/25/understanding-cpu-steal-time-when-should-you-be-worried" target="_blank" rel="external">这里</a></em></p>
<p>公司的应用最近都已经迁移到自家的云计算平台上面了，所以也开始出现了无故Load飙升的情况，最后定位出来原因时虚拟机CPU资源竞争的情况。新知识Get！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2015/11/21/理解CPU-steal-time/" data-id="cijzwapqk0005o8bu6vjf9f4x" class="article-share-link" data-share="baidu" data-title="理解CPU steal time">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-亲身经历icloud账号被黑事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/06/亲身经历icloud账号被黑事件/" class="article-date">
  <time datetime="2015-10-06T02:04:00.000Z" itemprop="datePublished">10月 6 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/06/亲身经历icloud账号被黑事件/">亲身经历icloud账号被黑事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="2015-10-05">2015-10-05</h3><p><strong>下午3点</strong>：当时在高速上面聊天，老婆手机被无故重启，重启以后屏幕内容如下：<br>         XXX，如需解锁请在24小时内联系QQ：2075633961</p>
<p><strong>下午4点半</strong>：下高速直奔杭州平海路的apple销售点，找天才吧的技术人员解决，得到答复：他们无法解决，请打4006272273 解决。打了近1个小时的电话，由于换电话号码，忘记提示问题，一直没有成功。</p>
<p><strong>下午6点半</strong>：驱车回家，在家里面打开电脑，这个时候完了，电脑因为使用了同一个appId，也被锁了。老婆明天还要使用电脑办公，如何解决？打电话给4006272273，通过耐心尝试提示问题，终于想起来了2个，解决了icloud的密码问题，icloud账号重新找回了并且修改了密码。手机能够重新激活了，但是数据被抹掉了，算了，大不了，花半个小时重装软件。问题是现在电脑如何解决？还是需要4位的pin码啊。继续4006272273转到mac部门沟通，说是要到实体店售后解决。接着我就电话给实体店售后，售后告诉我不能解决，要4006272273有更高的权限解决。</p>
<pre><code>400热线的客服的让我找实体店技术人员解决，实体店技术人员让我找400热线的客服解决？ 所以这个就是个死循环了？ 这个是什么情况？？？
</code></pre><p>带着不解和火气直奔了苹果的实体店，很理性的询问了技术人员，咨询情况，经过近15分钟的沟通，然后得到的答复是：先要预约，然后要购买凭证，最后电脑的数据会被抹掉。总结下就是：</p>
<pre><code>处理周期是7-15天，然后数据会被抹掉，不能恢复！
</code></pre><p>我心里就明白了：苹果天才吧的技术人员 是 根本不能解决这个问题，然后才和400热线的客服人员进行推脱的！苹果的售后竟然存在如此大的问题，最让人受不了的方式就是这种推诿，浪费消费者的时间和精力。如果早点告诉我们：我们解决不了。我们就会找另外的方案解决了。</p>
<p>最后的结果就是，理性的接受勒索，和对应的QQ ID沟通，支付宝200，然后得到pin码，电脑解锁，保全数据，重装系统，对所有相关邮箱账号都重置了密码和绑定了手机，开启二次验证。icloud账号也开启了二次验证，3天后生效。</p>
<pre><code>虽然icloud账号开启了二次验证，也只是防止被修改密码，如果icloud账号泄露，那么电脑一样可以被锁和抹掉数据！！！
</code></pre><p>总结有两种解决办公电脑不受icloud账号影响的方式：</p>
<ol>
<li>最安全方案：关闭mac上的找回我的mac功能。代价是人肉保证电脑不被偷。</li>
<li>次优方案：软件都使用正版。这种方式最大程度上面减少电脑方面泄露icloud信息，但是不能保证解决icloud相关邮箱和手机icloud信息泄露的情况。</li>
</ol>
<p>小计这件事情的目的：</p>
<ol>
<li>是提醒身边使用mac的朋友，当心icloud账号被人盯上了。</li>
<li>原来apple的售后也是有这么无力的时候，但是却又极力的不想表现出来，让人恶心，基本的诚实也没有。</li>
<li>之前都是听安全部的同事分享黑客和黑产内容，现在算是亲身经历了。2075633961 这个QQ号和他聊天的感觉，看起来是一个专业的客服人员，举报或许有点用吧，现在po一下这个QQ。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2015/10/06/亲身经历icloud账号被黑事件/" data-id="cijzwapqp000do8buv1j4px2s" class="article-share-link" data-share="baidu" data-title="亲身经历icloud账号被黑事件">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Life/">Life</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-本地缓存组件选型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/04/本地缓存组件选型/" class="article-date">
  <time datetime="2015-09-04T03:30:53.000Z" itemprop="datePublished">9月 4 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/04/本地缓存组件选型/">本地缓存组件选型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>需求： 记录系统执行数据，能持久化，容错。</p>
<h2 id="Guava">Guava</h2><p>官网就没有说有persistent的功能，直接略过。</p>
<h2 id="ehcache">ehcache</h2><p>企业版需要缴费，然后持久化功能和保证重启可用的功能都需要缴费。</p>
<p>看看开源版ehcache的是否可以满足，现状是：可以在只是DiskStore相关配置，让cache把内容序列化后直接overflow到文件。<br>现在问题是：</p>
<h4 id="重启">重启</h4><p>重启以后，是重新新建文件并覆盖同名文件—也就是之前同名cache生成的文件。尝试出使用自己实现的RebootCacheLoaderFactory implemets BootstrapCacheLoaderFactory可以来创建 RebootCacheLoader implements BootstrapCacheLoader来实现内容。</p>
<p>RootbootCacheLoaderFactory：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">RebootCacheLoaderFactory</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BootstrapCacheLoaderFactory</span> {</span>
    <span class="annotation">@Override</span>
    public <span class="type">BootstrapCacheLoader</span> createBootstrapCacheLoader(<span class="type">Properties</span> properties) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RebootCacheLoader</span>();
    }
}
</code></pre><p>RebootCacheLoader：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebootCacheLoader</span> <span class="keyword">implements</span> <span class="title">BootstrapCacheLoader</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Ehcache cache)</span> <span class="keyword">throws</span> CacheException </span>{
        cache.put(<span class="keyword">new</span> Element(<span class="string">"haha"</span>+Math.random(), Math.random()));
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsynchronous</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> RebootCacheLoader();
    }
}
</code></pre><p>Main：</p>
<pre><code><span class="typename">String</span> path = <span class="string">"/tmp/ehcache/"</span>;
<span class="typename">String</span> cacheManagerName = <span class="string">"cacheManagerName"</span>;
Long diskSizeBytes = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>L;
<span class="typename">String</span> cache1Name = <span class="string">"40006_1232131231312"</span>;
<span class="typename">String</span> cache2Name = <span class="string">"40002_1232131231312"</span>;

<span class="keyword">Configuration</span> <span class="keyword">configuration</span> = <span class="keyword">new</span> <span class="keyword">Configuration</span>();
<span class="keyword">configuration</span>.setName(cacheManagerName);
CacheConfiguration defaultCacheConfiguration = <span class="keyword">new</span> CacheConfiguration();
defaultCacheConfiguration.overflowToOffHeap(false);
defaultCacheConfiguration.overflowToDisk(true);
defaultCacheConfiguration.maxEntriesLocalHeap(<span class="number">1</span>); //<span class="number">0</span> <span class="keyword">is</span> <span class="keyword">not</span> limited, DiskStore, MemStore will <span class="keyword">all</span> have the element; <span class="number">1</span> means just the last element will be <span class="keyword">in</span> memory.
defaultCacheConfiguration.maxBytesLocalDisk(<span class="number">2</span>, MemoryUnit.MEGABYTES); //模糊的界定，异步写入，主线程结束了，还有一些记录没有记录的，会丢失数据。
defaultCacheConfiguration.addBootstrapCacheLoaderFactory(<span class="keyword">new</span> CacheConfiguration.BootstrapCacheLoaderFactoryConfiguration().className(
            <span class="string">"com.daniel.test.RebootCacheLoaderFactory"</span>
    ));

<span class="keyword">configuration</span>.setDefaultCacheConfiguration(defaultCacheConfiguration);

CacheManager cacheManager = <span class="keyword">new</span> CacheManager(<span class="keyword">configuration</span>);

cacheManager.addCache(cache1Name);
</code></pre><p>在<strong>cacheManager.addCache(cache1Name)</strong>方法里面clone一个defaultCache，然后改个名字，然后initialize cache完成之后，调用cache.bootstrap()方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">bootstrap</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (!disabled &amp;&amp; bootstrapCacheLoader != <span class="keyword">null</span>) {
        bootstrapCacheLoader.load(<span class="keyword">this</span>);
    }

}
</code></pre><p>然后就可以load到自定义信息了，因为底层就是用了java自带序列化来存储Element对象，方法在：<strong>DiskStorageFactory.serializeElement()</strong></p>
<h3 id="持久化">持久化</h3><p>从最近本的cache.put()方法不断debug进去，发现DiskStore.put()引用了segment.put()，然后Element的行记录的包装类PlaceHolder里面的install方法调用了如下内容：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">installed</span><span class="params">()</span> </span>{
    DiskStorageFactory.<span class="keyword">this</span>.schedule(<span class="keyword">new</span> PersistentDiskWriteTask(<span class="keyword">this</span>));
}
</code></pre><p>看着感觉很悲剧，果然看到里面是一个ScheduledThreadPoolExecutor在执行，实体是DiskStorageFactory里面的diskWriter，然后是默认生成的，还不能修改队列啥的：</p>
<pre><code>diskWriter <span class="subst">=</span> <span class="literal">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="literal">new</span> ThreadFactory() {
    <span class="keyword">public</span> <span class="keyword">Thread</span> newThread(Runnable r) {
        <span class="keyword">Thread</span> t <span class="subst">=</span> <span class="literal">new</span> <span class="keyword">Thread</span>(r, file<span class="built_in">.</span>getName());
        t<span class="built_in">.</span>setDaemon(<span class="literal">false</span>);
        <span class="keyword">return</span> t;
    }
});
</code></pre><p>这个构造函数，消息队列是默认11个的PriorityQueue，所以机器中断可能导致数据还在queue里面没被写入到磁盘。这个组件不能用了！！！</p>
<h2 id="OSCache">OSCache</h2><p>名声挺好的，搜了下，已经不维护了，略过</p>
<h2 id="JCS">JCS</h2><p>JCS是插件式管看着很棒，persistent功能介绍也很强大，符合我的需求，看了一眼bugfix清单，关于persistet的bug那么多，最新的版本还是beta的，完全不敢用，不想自找麻烦。</p>
<h2 id="FQueue">FQueue</h2><p>转换下思路了。如果说持久化要做到可靠性最佳，理论上面就应该是同步插入数据到磁盘；如果还要保证消费的顺序性，想了一种方案，如下:</p>
<p><img src="http://7oxfl2.com1.z0.glb.clouddn.com/思路.jpg" alt="思路">：</p>
<p>虽然很开心的想出来了，但是可靠性却不能保证啊。我们的存储使用的是HBASE，scheme设计是：rowkey用index，所有相同index的记录都需要记录到一行记录里面。如果我再搞一个持久化的重试队列，Queue的Element先poll出来，push到retryQueue extends LinkedList，并在内存存储retryQueue的Element和位置的关系Map，然后等异步插入HBase数据完成之后，利用内存关系来做删除，这个时候有两个问题：</p>
<ol>
<li><p>fQueue使用是FIFO的Queue，如何在记录位置并删除呢，效率是否有影响？想象下多个线程同时操作一个文件。如果要做, 可能需要学ehcache的方式，在内存里面映射文件为一个map，做segment分段加锁，然后在内存中删除，同时交给一个只有一个线程的线程池异步删除对应文件数据，那这样最多就2个线程抢占一个文件，一个写入，一个删除；那么问题来了，因为是异步，所以可能存在crash的时候内存删除了，文件数据没删除的情况，对异常恢复造成影响，类似之后提到的2问题。</p>
</li>
<li><p>插入HBase的时候，机器crash了，我们不知道是否真的插入成功了，就需要在机器重启的时候重新插入，这个时候会在同一行记录里面append内容一样的column了。</p>
</li>
</ol>
<p>换一种思路：<br>我每一个index下的内容都生成一个持久化文件，并在内存中存储一个mark标记，标记是否index文件生成完了，监听器监听 <strong>生成完</strong>的状态，然后交给一个线程处理这个index相关的一个文件，因为内容是顺序的，所以直接拼装成一条记录，并且写入，写入成功之后，删除这个index对应的文件。异常状况处理如下：</p>
<ol>
<li><p>index下内容生成一半，crash，重启以后首先消费掉这些数据并做插入到HBase，保证异常数据也能够被系统得到。</p>
</li>
<li><p>插入HBase时，crash，重启以后同样重复消费文件数据，构造一条记录，插入。如果上次已经插入通用的rowkey数据，那么HBase自己会做update，那么业务上面完全没有影响，就是DB方面多update了一次。</p>
</li>
</ol>
<p>恩，现在感觉完美了。</p>
<p>FQueue默认文件大小是300M，用400个线程同时创建文件，ssd 硬盘，2.5GCPU的配置直接卡爆。然后调整为默认为1M。重写了三个类：FQueue.java, FSQueue.java, LogEntity.java</p>
<p>HMFQueue.java</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">HMFQueue</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>{
    fsQueue = <span class="keyword">new</span> HMFSQueue(path, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>); <span class="comment">//默认是1M大小</span>
}

<span class="annotation">@Override</span>
<span class="comment">//not thread safe, be careful , 添加了iterator的支持，需要修改FSQueue和LogEntity</span>
<span class="keyword">public</span> Iterator&lt;<span class="keyword">byte</span>[]&gt; iterator() {
    <span class="keyword">try</span> {
        fsQueue.curseToHead();
    } <span class="keyword">catch</span> (IOException e) {
        log.<span class="keyword">error</span>(<span class="string">" cannot open the file!"</span>,e );
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"failed to move to head!"</span>);
    } <span class="keyword">catch</span> (FileFormatException e) {
        log.<span class="keyword">error</span>(<span class="string">"failed to move to head! the file format is wrong"</span>,e );
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"failed to move to head!"</span>);
    }

    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;<span class="keyword">byte</span>[]&gt;() {

        <span class="annotation">@Override</span>
         <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{
            <span class="function"><span class="keyword">return</span> fsQueue.<span class="title">hasNext</span><span class="params">()</span></span>;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">byte</span>[] next() {
            <span class="function"><span class="keyword">return</span> fsQueue.<span class="title">readNextAndMove</span><span class="params">()</span></span>;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{
            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove operation is not supported here!"</span>);
        }
    };
}
</code></pre><p>HMFSQueue.java 添加如下方法支持文件的重头读取和遍历</p>
<pre><code><span class="comment">//not thread safe 定位到文件的头部，更新index</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">curseToHead</span><span class="params">()</span>  <span class="keyword">throws</span> IOException, FileFormatException </span>{
    <span class="keyword">int</span> fileNum = -<span class="number">1</span>;
    File dir = <span class="keyword">new</span> File(path);
    <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory()){
        <span class="keyword">if</span>(dir.listFiles() != <span class="keyword">null</span> &amp;&amp; dir.listFiles().length &gt; <span class="number">0</span>){
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Integer.MAX_VALUE; i++){
                String fileName = path + fileSeparator + filePrefix + <span class="string">"data_"</span> + i + <span class="string">".idb"</span>;
                File file = <span class="keyword">new</span> File(fileName);
                <span class="keyword">if</span>(file.exists()){
                    fileNum = i;
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span>(fileNum != -<span class="number">1</span>){
                <span class="keyword">if</span> (writerHandle.getCurrentFileNumber() == fileNum) {
                    readerHandle = writerHandle;
                }<span class="keyword">else</span>{
                    readerHandle = createLogEntity(path + fileSeparator + filePrefix + <span class="string">"data_"</span> + fileNum + <span class="string">".idb"</span>, db,
                            fileNum);
                }
                readerHandle.resetReaderPosition();
            }
        }
    }
}

<span class="comment">//not thread safe 判断是否有下一条数据</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>{
    <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        b = readerHandle.readNext();
    } <span class="keyword">catch</span> (FileEOFException e) {
        <span class="keyword">int</span> nextfile = readerHandle.getNextFile();
        readerHandle.close();
        <span class="comment">// 更新下一次读取的位置和索引</span>
        db.putReaderPosition(HMLogEntity.messageStartPosition);
        db.putReaderIndex(nextfile);
        <span class="keyword">if</span> (writerHandle.getCurrentFileNumber() == nextfile) {
            readerHandle = writerHandle;
        } <span class="keyword">else</span> {
            <span class="keyword">try</span> {
                readerHandle = createLogEntity(path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, db,
                        nextfile);
            } <span class="keyword">catch</span> (IOException e1) {
                log.<span class="keyword">error</span>(<span class="string">"failed to read file: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>,e1);
            } <span class="keyword">catch</span> (FileFormatException e1) {
                log.<span class="keyword">error</span>(<span class="string">"the file has wrong format: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, e1);
            }
        }
        <span class="keyword">try</span> {
            b = readerHandle.readNext();
        } <span class="keyword">catch</span> (FileEOFException e1) {
            log.<span class="keyword">error</span>(<span class="string">"read new log file FileEOFException error occurred"</span>,e1);
        }
    }
    <span class="keyword">if</span> (b != <span class="keyword">null</span>) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="comment">//not thread safe 读取下一个并且更新索引</span>
<span class="keyword">public</span> <span class="keyword">byte</span>[] readNextAndMove(){
    <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        b = readerHandle.readNextAndMove();
    } <span class="keyword">catch</span> (FileEOFException e) {
        <span class="keyword">int</span> nextfile = readerHandle.getNextFile();
        readerHandle.close();
        <span class="comment">// 更新下一次读取的位置和索引</span>
        db.putReaderPosition(HMLogEntity.messageStartPosition);
        db.putReaderIndex(nextfile);
        <span class="keyword">if</span> (writerHandle.getCurrentFileNumber() == nextfile) {
            readerHandle = writerHandle;
        } <span class="keyword">else</span> {
            <span class="keyword">try</span> {
                readerHandle = createLogEntity(path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, db,
                        nextfile);
            } <span class="keyword">catch</span> (IOException e1) {
                log.<span class="keyword">error</span>(<span class="string">"failed to read file: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, e1);
            } <span class="keyword">catch</span> (FileFormatException e1) {
                log.<span class="keyword">error</span>(<span class="string">"the file has wrong format: "</span> + path + fileSeparator + filePrefix + <span class="string">"data_"</span> + nextfile + <span class="string">".idb"</span>, e1);
            }
        }
        <span class="keyword">try</span> {
            b = readerHandle.readNextAndMove();
        } <span class="keyword">catch</span> (FileEOFException e1) {
            log.<span class="keyword">error</span>(<span class="string">"read new log file FileEOFException error occurred"</span>,e1);
        }
    }
    <span class="keyword">return</span> b;
}

<span class="comment">//删除消息队列相关数据文件</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">delQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileFormatException </span>{
    FileUtils.deleteDirectory(<span class="keyword">new</span> File(path));
}
</code></pre><p>HMLogEntity.java</p>
<pre><code><span class="keyword">public</span> HMLogEntity(<span class="built_in">String</span> path, LogIndex db, int fileNumber,
                 int fileLimitLength) throws IOException, FileFormatException {
    <span class="attribute">...</span><span class="attribute">...</span><span class="built_in">..
    </span><span class="keyword">if</span> (file<span class="built_in">.</span>exists() <span class="subst">==</span> <span class="literal">false</span>) {
        createLogEntity();
        <span class="comment">//FileRunner.addCreateFile(Integer.toString(fileNumber + 1)); //注释掉，如果文件切片为1M时候，提前创建有问题：由于是异步的，消费的时候会存在还没有创建成功，写入失败的情况。</span>
    } <span class="keyword">else</span> {
        <span class="attribute">...</span><span class="attribute">...</span><span class="built_in">..
    </span>}      
}
</code></pre><p>测试下性能，单线程写20W的数据花了9s；</p>
<p>但是多线程写入多个文件性能和稳定性可能有问题了：</p>
<ol>
<li><p>400个线程，每个线程创建自己的文件，写入300条数据，遍历300条数据，删除自己创建写入的文件总共要6.1s，且一切正常。</p>
</li>
<li><p>400个线程，每个线程创建自己的文件，写入400条数据，遍历400条数据，删除自己创建写入的文件出现写入失败和读取失败的情况：240个线程写入完成，133个线程遍历完成，且没有异常抛出。</p>
</li>
<li><p>600个线程，每个线程创建自己的文件，写入300条数据，遍历300条数据，删除自己创建写入的文件出现写入失败和读取失败的情况：244个线程写入完成，160个线程遍历完成，且没有异常抛出。</p>
</li>
</ol>
<p>1的情况已经是达到了临界值。2，3都会出现不稳定的情况，我去，这个是啥原因呢？？百思不得其解。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2015/09/04/本地缓存组件选型/" data-id="cijzwapqm0008o8bunfne5382" class="article-share-link" data-share="baidu" data-title="本地缓存组件选型">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Dynamic-Bean" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/09/Dynamic-Bean/" class="article-date">
  <time datetime="2015-04-09T02:19:28.000Z" itemprop="datePublished">4月 9 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/09/Dynamic-Bean/">Dynamic Bean</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>突然对一些基础类库的代码感了兴趣，于是最先看起了Apache的commons-beanutils这个包，然后顺藤摸瓜式的了解JavaBeans和Dynamic Bean相关的知识。</p>
<h3 id="common-beanutils-1-9-2">common-beanutils-1.9.2</h3><p>此包主要功能如下：</p>
<pre><code>创建动态的JavaBean及相关的util类型代码。
</code></pre><p>主要类的关系图如下：</p>
<p><img src="http://tempwork.qiniudn.com/apache-beanutils-class-diagram.jpg" alt="主要类图" title="Title"></p>
<ul>
<li><p>DynaClass, DynaProperty, DynaBean用来动态生成JavaBean, 主要使用了Java的原生包：java.lang.reflect &amp; java.beans</p>
</li>
<li><p>BeanUtilsBean是单例, 包含拷贝属性，克隆bean等util方法。</p>
</li>
</ul>
<p>举个<a href="http://www.javadb.com/simple-dynabean-example-apache-commons-beanutils/" title="beanutils实践例子" target="_blank" rel="external">栗子</a>：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.BasicDynaClass;</span>
<span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.DynaBean;</span>
<span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.DynaClass;</span>
<span class="preprocessor"><span class="keyword">import</span> org.apache.commons.beanutils.DynaProperty;</span>

<span class="comment">/**
 *
  * @author www.javadb.com
  */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynaBeanExample</span> </span>{

    <span class="keyword">private</span> <span class="keyword">final</span> String NR_OF_WHEELS = <span class="string">"numberOfWheels"</span>;

    <span class="keyword">private</span> <span class="keyword">void</span> runExample() {

        DynaClass dynaClass = <span class="keyword">new</span> BasicDynaClass(<span class="string">"Car"</span>, <span class="literal">null</span>,
            <span class="keyword">new</span> DynaProperty[]{
                <span class="keyword">new</span> DynaProperty(NR_OF_WHEELS, Integer.TYPE)});

        <span class="keyword">try</span> {
            DynaBean car = dynaClass.newInstance();
            car.<span class="keyword">set</span>(NR_OF_WHEELS, <span class="number">4</span>);

               System.out.println(<span class="string">"Number of wheels: "</span> + car.<span class="keyword">get</span>(NR_OF_WHEELS));

            System.out.println(<span class="string">"DynaBean is instance of DynaClass: "</span> + car.getDynaClass().getName());

        } <span class="keyword">catch</span> (IllegalAccessException | InstantiationException ex) {
            System.err.println(ex.getMessage());
        }
    }

   <span class="comment">/**
     * @param args the command line arguments
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        DynaBeanExample ac = <span class="keyword">new</span> DynaBeanExample();
        ac.runExample();
    }
}
</code></pre><p>所以看着这个使用的方式感觉还是蛮有意思的，可以动态的生成自己想要的<em>“Java Bean”</em>。</p>
<p>这个时候就开始好奇这个包会有什么问题呢？比如性能上面？然后就搜到了<a href="http://blog.athico.com/2006/11/just-say-no-to-dynabeans.html" title="反对使用beanutils包" target="_blank" rel="external">这个</a>。<strong>Drools</strong>很早就开始反对使用这种方式来构建<strong>Java Bean</strong>，理由很简单，系统兼容性不好，说这个包虽然实现的<strong>Dynamic Bean</strong>的功能，但是生成的DynaBean是不符合<strong>JavaBeans</strong>的规范的，将会引发一系列的代码兼容性的问题，所以不建议商业系统环境使用这个包—例如主流的ORM框架都只支持规范的<strong>JavaBeans</strong>。我们看代码可以发现<code>DynaBean</code>使用的是一个<code>Map&lt;String, DynaProperty&gt;</code>来存储属性的。</p>
<p>那么现在问题来了，什么是<strong>JavaBeans</strong> ?</p>
<h3 id="JavaBean">JavaBean</h3><p>参阅<a href="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/" target="_blank" rel="external">JavaBeans(TM) Specification</a>官方的文档，移步<a href="http://melody-dc.com/2015/04/09/JavaBeans-TM/" target="_blank" rel="external">解读大纲</a>。所以这个包是通过使用Introspection相关的类来实现<strong>Dynamic Bean</strong>，而不是构造符合<strong>JavaBeans</strong>规范的类.所以<strong>Drools</strong>就推荐使用了cglib来实现<strong>Dynamic Bean</strong>, 移步此<a href="http://sixlegs.com/blog/java/death-to-dynabeans.html" target="_blank" rel="external">参考</a>。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://danieldingzju.github.io/2015/04/09/Dynamic-Bean/" data-id="cijzwapr1000po8bu0b72ukrf" class="article-share-link" data-share="baidu" data-title="Dynamic Bean">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 16.67px;">JAVA</a><a href="/tags/Java/" style="font-size: 20px;">Java</a><a href="/tags/Life/" style="font-size: 10px;">Life</a><a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/30/taobao-tomcat类加载机制/">taobao-tomcat类加载机制</a>
          </li>
        
          <li>
            <a href="/2016/01/29/开源tomcat类加载机制/">开源tomcat类加载机制</a>
          </li>
        
          <li>
            <a href="/2016/01/28/ASM/">ASM</a>
          </li>
        
          <li>
            <a href="/2016/01/19/Zero-Copy/">Zero Copy</a>
          </li>
        
          <li>
            <a href="/2015/12/26/认识java-agent/">认识java agent</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 danielding<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
